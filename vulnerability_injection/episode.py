"""RL Episode runner for vulnerability fix demo.

Orchestrates the full pipeline:
1. Baseline security analysis on clean contract
2. Inject vulnerability using MuSe
3. Run mini-swe-agent to fix it
4. Final security analysis
5. Compute reward
"""

import json
import random
import shutil
import tempfile
from dataclasses import dataclass, field
from pathlib import Path

from vulnerability_injection.models import MuseMutation, OPERATOR_INFO
from vulnerability_injection.muse_wrapper import MuseInjector
from vulnerability_injection.security_tools import (
    Finding,
    RewardSignal,
    run_slither,
    run_aderyn,
    compare_findings,
)


@dataclass
class EpisodeResult:
    """Result of a single RL episode."""

    mutation: MuseMutation
    baseline_findings: list[Finding]
    final_findings: list[Finding]
    reward: RewardSignal
    agent_trajectory: dict = field(default_factory=dict)
    compilation_passed: bool = True
    episode_id: str = ""

    def to_dict(self) -> dict:
        return {
            "episode_id": self.episode_id,
            "mutation": self.mutation.to_dict(),
            "baseline_findings": [f.to_dict() for f in self.baseline_findings],
            "final_findings": [f.to_dict() for f in self.final_findings],
            "reward": self.reward.to_dict(),
            "compilation_passed": self.compilation_passed,
            "agent_trajectory": self.agent_trajectory,
        }


def setup_foundry_project(contract_path: Path, workspace: Path) -> Path:
    """Set up a minimal Foundry project structure.

    Args:
        contract_path: Path to the Solidity contract
        workspace: Directory to create the project in

    Returns:
        Path to the created project
    """
    src_dir = workspace / "src"
    src_dir.mkdir(parents=True, exist_ok=True)

    # Copy contract to src/
    shutil.copy(contract_path, src_dir / contract_path.name)

    # Create foundry.toml
    foundry_toml = workspace / "foundry.toml"
    foundry_toml.write_text("""[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc = "0.8.24"

[profile.default.optimizer]
enabled = true
runs = 200
""")

    return workspace


def generate_task_prompt(mutation: MuseMutation) -> str:
    """Generate the task prompt for the agent.

    Args:
        mutation: The mutation that was applied

    Returns:
        Task prompt string
    """
    info = OPERATOR_INFO.get(mutation.operator, {})
    vuln_name = info.get("name", mutation.operator)
    severity = info.get("severity", "unknown")
    description = info.get("description", "")

    return f"""The Solidity contract in src/ has a **{vuln_name}** vulnerability.
Your goal is to identify and fix the vulnerability while maintaining the contract's functionality.

## Vulnerability Details
- **Type**: {vuln_name}
- **Severity**: {severity}
- **Description**: {description}
- **Hint**: The vulnerability is around lines {mutation.start_line}-{mutation.end_line}

## Steps
1. Examine the contract: `cat src/*.sol`
2. Run security analysis: `. /opt/venv-main/bin/activate && slither src/ --print human-summary`
3. Fix the vulnerability by editing the contract
4. Verify it compiles: `forge build`
5. Re-run security analysis to confirm the fix
6. Submit when done: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`

Focus on fixing ONLY the {vuln_name} vulnerability. Do not refactor unrelated code.
"""


def run_security_analysis(project_path: str, env) -> list[Finding]:
    """Run both Slither and Aderyn on a project.

    Args:
        project_path: Path to the Foundry project (inside container)
        env: FoundryEnvironment instance

    Returns:
        Combined list of findings from both tools
    """
    findings = []

    # Run Slither
    slither_findings, _ = run_slither(f"{project_path}/src/", env)
    findings.extend(slither_findings)

    # Run Aderyn
    aderyn_findings, _ = run_aderyn(project_path, env)
    findings.extend(aderyn_findings)

    return findings


def run_episode(
    clean_contract: Path,
    output_dir: Path,
    model_name: str,
    operators: list[str] | None = None,
    yolo: bool = True,
    cost_limit: float = 3.0,
    docker_image: str = "yudai-complete:latest",
) -> EpisodeResult:
    """Run a single RL episode.

    Args:
        clean_contract: Path to the clean Solidity contract
        output_dir: Directory to save results
        model_name: LLM model to use
        operators: MuSe operators to use (None = all vulnerability operators)
        yolo: Run agent without confirmation
        cost_limit: Maximum cost for the agent

    Returns:
        EpisodeResult with all episode data
    """
    # Lazy imports to avoid circular dependencies
    from minisweagent.agents.default import DefaultAgent
    from minisweagent.environments.foundry import FoundryEnvironment
    from minisweagent.models import get_model
    from minisweagent.run.utils.save import save_traj

    import yaml
    from minisweagent.config import builtin_config_dir

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    episode_id = f"ep_{random.randint(10000, 99999)}"

    # Create temporary workspace
    workspace = Path(tempfile.mkdtemp(prefix="rl_episode_"))

    try:
        # Step 1: Set up Foundry project
        project = setup_foundry_project(clean_contract, workspace)

        # Step 2: Inject vulnerability using MuSe
        injector = MuseInjector(operators=operators)
        mutations = injector.inject(clean_contract, workspace / "mutants", operators=operators)

        if not mutations:
            raise RuntimeError("MuSe did not generate any mutations")

        # Select a random mutation
        mutation = random.choice(mutations)

        # Copy mutated contract to project
        if mutation.mutant_path:
            mutant_src = Path(mutation.mutant_path)
            if mutant_src.exists():
                shutil.copy(mutant_src, project / "src" / clean_contract.name)

        # Step 3: Initialize environment with project mounted
        env = FoundryEnvironment(project_path=str(project), image=docker_image)

        # Step 4: Run baseline security analysis (on mutated contract)
        baseline_findings = run_security_analysis("/workspace", env)

        # Step 5: Load agent config and run agent
        config_path = builtin_config_dir / "foundry.yaml"
        config = yaml.safe_load(config_path.read_text())

        if yolo:
            config.setdefault("agent", {})["mode"] = "yolo"
        config.setdefault("agent", {})["cost_limit"] = cost_limit

        model = get_model(model_name, config.get("model", {}))
        agent = DefaultAgent(model, env, **config.get("agent", {}))

        task = generate_task_prompt(mutation)
        exit_status, result = agent.run(task)

        # Save trajectory
        traj_path = output_dir / f"{episode_id}.traj.json"
        save_traj(agent, traj_path, exit_status=exit_status, result=result, print_path=False)

        # Step 6: Run final security analysis
        final_findings = run_security_analysis("/workspace", env)

        # Check if compilation passed
        compile_result = env.execute("forge build")
        compilation_passed = compile_result.get("returncode", 1) == 0

        # Step 7: Compute reward
        reward = compare_findings(baseline_findings, final_findings, mutation.operator)
        reward.compilation_passed = compilation_passed

        # Adjust reward for compilation failure
        if not compilation_passed:
            reward.total_reward = -1.0

        # Build result
        episode_result = EpisodeResult(
            episode_id=episode_id,
            mutation=mutation,
            baseline_findings=baseline_findings,
            final_findings=final_findings,
            reward=reward,
            compilation_passed=compilation_passed,
            agent_trajectory={
                "messages": agent.messages,
                "exit_status": exit_status,
                "result": result,
                "cost": agent.model.cost,
                "n_calls": agent.model.n_calls,
            },
        )

        # Save episode result
        result_path = output_dir / f"{episode_id}.result.json"
        result_path.write_text(json.dumps(episode_result.to_dict(), indent=2))

        return episode_result

    finally:
        # Cleanup
        shutil.rmtree(workspace, ignore_errors=True)


def run_episode_from_mutation(
    mutated_contract: Path,
    mutation: MuseMutation,
    output_dir: Path,
    model_name: str,
    yolo: bool = True,
    cost_limit: float = 3.0,
    docker_image: str = "yudai-complete:latest",
) -> EpisodeResult:
    """Run an episode with a pre-mutated contract.

    This is useful when you've already generated mutations and want to
    run the agent on a specific one.

    Args:
        mutated_contract: Path to the already-mutated contract
        mutation: The MuseMutation that was applied
        output_dir: Directory to save results
        model_name: LLM model to use
        yolo: Run agent without confirmation
        cost_limit: Maximum cost for the agent

    Returns:
        EpisodeResult with all episode data
    """
    from minisweagent.agents.default import DefaultAgent
    from minisweagent.environments.foundry import FoundryEnvironment
    from minisweagent.models import get_model
    from minisweagent.run.utils.save import save_traj

    import yaml
    from minisweagent.config import builtin_config_dir

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    episode_id = f"ep_{random.randint(10000, 99999)}"
    workspace = Path(tempfile.mkdtemp(prefix="rl_episode_"))

    try:
        # Set up project with mutated contract
        project = setup_foundry_project(mutated_contract, workspace)

        # Initialize environment
        env = FoundryEnvironment(project_path=str(project), image=docker_image)

        # Run baseline analysis
        baseline_findings = run_security_analysis("/workspace", env)

        # Load config and run agent
        config_path = builtin_config_dir / "foundry.yaml"
        config = yaml.safe_load(config_path.read_text())

        if yolo:
            config.setdefault("agent", {})["mode"] = "yolo"
        config.setdefault("agent", {})["cost_limit"] = cost_limit

        model = get_model(model_name, config.get("model", {}))
        agent = DefaultAgent(model, env, **config.get("agent", {}))

        task = generate_task_prompt(mutation)
        exit_status, result = agent.run(task)

        traj_path = output_dir / f"{episode_id}.traj.json"
        save_traj(agent, traj_path, exit_status=exit_status, result=result, print_path=False)

        # Final analysis
        final_findings = run_security_analysis("/workspace", env)

        compile_result = env.execute("forge build")
        compilation_passed = compile_result.get("returncode", 1) == 0

        reward = compare_findings(baseline_findings, final_findings, mutation.operator)
        reward.compilation_passed = compilation_passed

        if not compilation_passed:
            reward.total_reward = -1.0

        episode_result = EpisodeResult(
            episode_id=episode_id,
            mutation=mutation,
            baseline_findings=baseline_findings,
            final_findings=final_findings,
            reward=reward,
            compilation_passed=compilation_passed,
            agent_trajectory={
                "messages": agent.messages,
                "exit_status": exit_status,
                "result": result,
                "cost": agent.model.cost,
                "n_calls": agent.model.n_calls,
            },
        )

        result_path = output_dir / f"{episode_id}.result.json"
        result_path.write_text(json.dumps(episode_result.to_dict(), indent=2))

        return episode_result

    finally:
        shutil.rmtree(workspace, ignore_errors=True)

