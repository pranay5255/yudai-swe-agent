"""RL Episode runner for vulnerability fix demo.

Orchestrates the full pipeline:
1. Baseline security analysis on clean contract
2. Inject vulnerability using MuSe
3. Run mini-swe-agent to fix it
4. Final security analysis
5. Compute reward
"""

import json
import random
import shutil
import tempfile
from dataclasses import dataclass, field
from pathlib import Path

from vulnerability_injection.environment_builder import EnvironmentBuilder
from vulnerability_injection.models import OPERATOR_INFO, MuseMutation
from vulnerability_injection.muse_wrapper import MuseInjector
from vulnerability_injection.security_tools import (
    Finding,
    RewardSignal,
    compare_findings,
    run_aderyn,
    run_slither,
)


@dataclass
class EpisodeResult:
    """Result of a single RL episode."""

    mutation: MuseMutation
    baseline_findings: list[Finding]
    final_findings: list[Finding]
    reward: RewardSignal
    agent_trajectory: dict = field(default_factory=dict)
    compilation_passed: bool = True
    initial_compilation_failed: bool = False
    episode_id: str = ""

    def to_dict(self) -> dict:
        return {
            "episode_id": self.episode_id,
            "mutation": self.mutation.to_dict(),
            "baseline_findings": [f.to_dict() for f in self.baseline_findings],
            "final_findings": [f.to_dict() for f in self.final_findings],
            "reward": self.reward.to_dict(),
            "compilation_passed": self.compilation_passed,
            "initial_compilation_failed": self.initial_compilation_failed,
            "agent_trajectory": self.agent_trajectory,
        }


def setup_foundry_project(
    contract_path: Path, workspace: Path, use_docker: bool = False
) -> tuple[Path, bool, str]:
    """Set up a compilation-ready Foundry project with dependencies resolved.

    This function uses the EnvironmentBuilder to:
    1. Analyze the contract for version and dependencies
    2. Create appropriate Foundry project structure
    3. Install required dependencies (OpenZeppelin, etc.)
    4. Create stub contracts for external dependencies
    5. Verify compilation BEFORE returning

    Args:
        contract_path: Path to the Solidity contract
        workspace: Directory to create the project in
        use_docker: Whether to use Docker for compilation verification

    Returns:
        Tuple of (project_path, compilation_success, error_message)
    """
    import logging

    logger = logging.getLogger(__name__)

    builder = EnvironmentBuilder(use_docker=use_docker)
    result = builder.build_environment(contract_path, workspace)

    if not result.success:
        error_msg = f"Failed to build environment: {', '.join(result.errors)}"
        logger.error(error_msg)
        logger.error(f"Compilation output:\n{result.compilation_output[:1000]}")
        return workspace, False, error_msg

    logger.info(f"âœ“ Environment ready - contract compiles successfully")
    logger.info(f"  Template: {result.template_used}")
    logger.info(f"  Version: {result.metadata.solidity_version}")

    return workspace, True, ""


def generate_task_prompt(mutation: MuseMutation) -> str:
    """Generate the task prompt for the agent.

    Args:
        mutation: The mutation that was applied

    Returns:
        Task prompt string
    """
    info = OPERATOR_INFO.get(mutation.operator, {})
    vuln_name = info.get("name", mutation.operator)
    severity = info.get("severity", "unknown")
    description = info.get("description", "")

    return f"""The Solidity contract in src/ has a **{vuln_name}** vulnerability.
Your goal is to identify and fix the vulnerability while maintaining the contract's functionality.

## Vulnerability Details
- **Type**: {vuln_name}
- **Severity**: {severity}
- **Description**: {description}
- **Hint**: The vulnerability is around lines {mutation.start_line}-{mutation.end_line}

## Steps
1. Examine the contract: `cat src/*.sol`
2. Run security analysis: `. /opt/venv-main/bin/activate && slither src/ --print human-summary`
3. Fix the vulnerability by editing the contract
4. Verify it compiles: `forge build`
5. Re-run security analysis to confirm the fix
6. Submit when done: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`

Focus on fixing ONLY the {vuln_name} vulnerability. Do not refactor unrelated code.
"""


def run_security_analysis(project_path: str, env) -> list[Finding]:
    """Run both Slither and Aderyn on a project.

    Args:
        project_path: Path to the Foundry project (inside container)
        env: FoundryEnvironment instance

    Returns:
        Combined list of findings from both tools
    """
    findings = []

    # Run Slither
    slither_findings, _ = run_slither(f"{project_path}/src/", env)
    findings.extend(slither_findings)

    # Run Aderyn
    aderyn_findings, _ = run_aderyn(project_path, env)
    findings.extend(aderyn_findings)

    return findings


def run_episode(
    clean_contract: Path,
    output_dir: Path,
    model_name: str,
    operators: list[str] | None = None,
    yolo: bool = True,
    cost_limit: float = 3.0,
    docker_image: str = "yudai-complete:latest",
    config_path: str | Path | None = None,
) -> EpisodeResult:
    """Run a single RL episode.

    Args:
        clean_contract: Path to the clean Solidity contract
        output_dir: Directory to save results
        model_name: LLM model to use
        operators: MuSe operators to use (None = all vulnerability operators)
        yolo: Run agent without confirmation
        cost_limit: Maximum cost for the agent
        config_path: Optional config file (name or path) for the agent prompts

    Returns:
        EpisodeResult with all episode data
    """
    # Lazy imports to avoid circular dependencies
    import yaml

    from minisweagent.agents.default import DefaultAgent
    from minisweagent.config import builtin_config_dir, get_config_path
    from minisweagent.environments.foundry import FoundryEnvironment
    from minisweagent.models import get_model
    from minisweagent.run.utils.save import save_traj

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    episode_id = f"ep_{random.randint(10000, 99999)}"

    # Create temporary workspace
    workspace = Path(tempfile.mkdtemp(prefix="rl_episode_"))

    try:
        # Step 1: Inject vulnerability using MuSe (on original contract)
        injector = MuseInjector(operators=operators)
        mutations = injector.inject(clean_contract, workspace / "mutants", operators=operators)

        if not mutations:
            raise RuntimeError("MuSe did not generate any mutations")

        # Select a random mutation
        mutation = random.choice(mutations)

        # Get path to mutated contract
        mutant_contract = Path(mutation.mutant_path) if mutation.mutant_path else clean_contract
        if not mutant_contract.exists():
            raise RuntimeError(f"Mutated contract not found: {mutant_contract}")

        # Step 2: Set up Foundry project with proper dependencies for MUTATED contract
        # This ensures the vulnerable version compiles before the agent starts
        project_workspace = workspace / "foundry_project"
        project, compile_success, compile_error = setup_foundry_project(
            mutant_contract, project_workspace, use_docker=False
        )

        if not compile_success:
            # Log warning but continue - some old contracts may not compile initially
            import logging

            logger = logging.getLogger(__name__)
            logger.warning(
                f"Mutated contract failed initial compilation: {compile_error[:500]}"
            )
            logger.warning("Continuing anyway - agent will need to fix compilation issues too")
            # Mark as pre-compilation failure for reward calculation
            initial_compile_failed = True
        else:
            initial_compile_failed = False

        # Step 3: Initialize environment with project mounted
        env = FoundryEnvironment(project_path=str(project), image=docker_image)

        # Step 4: Run baseline security analysis (on mutated contract)
        baseline_findings = run_security_analysis("/workspace", env)

        # Step 5: Load agent config and run agent
        config_spec = config_path or (builtin_config_dir / "foundry.yaml")
        resolved_config_path = get_config_path(config_spec)
        config = yaml.safe_load(resolved_config_path.read_text())

        if yolo:
            config.setdefault("agent", {})["mode"] = "yolo"
        config.setdefault("agent", {})["cost_limit"] = cost_limit

        model = get_model(model_name, config.get("model", {}))
        agent = DefaultAgent(model, env, **config.get("agent", {}))

        task = generate_task_prompt(mutation)
        exit_status, result = agent.run(task)

        # Save trajectory
        traj_path = output_dir / f"{episode_id}.traj.json"
        save_traj(agent, traj_path, exit_status=exit_status, result=result, print_path=False)

        # Step 6: Run final security analysis
        final_findings = run_security_analysis("/workspace", env)

        # Check if compilation passed
        compile_result = env.execute("forge build")
        compilation_passed = compile_result.get("returncode", 1) == 0

        # Step 7: Compute reward
        reward = compare_findings(baseline_findings, final_findings, mutation.operator)
        reward.compilation_passed = compilation_passed

        # Adjust reward for compilation failure
        if not compilation_passed:
            reward.total_reward = -1.0

        # Build result
        episode_result = EpisodeResult(
            episode_id=episode_id,
            mutation=mutation,
            baseline_findings=baseline_findings,
            final_findings=final_findings,
            reward=reward,
            compilation_passed=compilation_passed,
            initial_compilation_failed=initial_compile_failed,
            agent_trajectory={
                "messages": agent.messages,
                "exit_status": exit_status,
                "result": result,
                "cost": agent.model.cost,
                "n_calls": agent.model.n_calls,
            },
        )

        # Save episode result
        result_path = output_dir / f"{episode_id}.result.json"
        result_path.write_text(json.dumps(episode_result.to_dict(), indent=2))

        return episode_result

    finally:
        # Cleanup
        shutil.rmtree(workspace, ignore_errors=True)


def run_episode_from_mutation(
    mutated_contract: Path,
    mutation: MuseMutation,
    output_dir: Path,
    model_name: str,
    yolo: bool = True,
    cost_limit: float = 3.0,
    docker_image: str = "yudai-complete:latest",
    config_path: str | Path | None = None,
) -> EpisodeResult:
    """Run an episode with a pre-mutated contract.

    This is useful when you've already generated mutations and want to
    run the agent on a specific one.

    Args:
        mutated_contract: Path to the already-mutated contract
        mutation: The MuseMutation that was applied
        output_dir: Directory to save results
        model_name: LLM model to use
        yolo: Run agent without confirmation
        cost_limit: Maximum cost for the agent
        config_path: Optional config file (name or path) for the agent prompts

    Returns:
        EpisodeResult with all episode data
    """
    import yaml

    from minisweagent.agents.default import DefaultAgent
    from minisweagent.config import builtin_config_dir, get_config_path
    from minisweagent.environments.foundry import FoundryEnvironment
    from minisweagent.models import get_model
    from minisweagent.run.utils.save import save_traj

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    episode_id = f"ep_{random.randint(10000, 99999)}"
    workspace = Path(tempfile.mkdtemp(prefix="rl_episode_"))

    try:
        # Set up project with mutated contract and verify compilation
        project, compile_success, compile_error = setup_foundry_project(
            mutated_contract, workspace, use_docker=False
        )

        initial_compile_failed = not compile_success
        if initial_compile_failed:
            import logging

            logger = logging.getLogger(__name__)
            logger.warning(f"Initial compilation failed: {compile_error[:500]}")

        # Initialize environment
        env = FoundryEnvironment(project_path=str(project), image=docker_image)

        # Run baseline analysis
        baseline_findings = run_security_analysis("/workspace", env)

        # Load config and run agent
        config_spec = config_path or (builtin_config_dir / "foundry.yaml")
        resolved_config_path = get_config_path(config_spec)
        config = yaml.safe_load(resolved_config_path.read_text())

        if yolo:
            config.setdefault("agent", {})["mode"] = "yolo"
        config.setdefault("agent", {})["cost_limit"] = cost_limit

        model = get_model(model_name, config.get("model", {}))
        agent = DefaultAgent(model, env, **config.get("agent", {}))

        task = generate_task_prompt(mutation)
        exit_status, result = agent.run(task)

        traj_path = output_dir / f"{episode_id}.traj.json"
        save_traj(agent, traj_path, exit_status=exit_status, result=result, print_path=False)

        # Final analysis
        final_findings = run_security_analysis("/workspace", env)

        compile_result = env.execute("forge build")
        compilation_passed = compile_result.get("returncode", 1) == 0

        reward = compare_findings(baseline_findings, final_findings, mutation.operator)
        reward.compilation_passed = compilation_passed

        if not compilation_passed:
            reward.total_reward = -1.0

        episode_result = EpisodeResult(
            episode_id=episode_id,
            mutation=mutation,
            baseline_findings=baseline_findings,
            final_findings=final_findings,
            reward=reward,
            compilation_passed=compilation_passed,
            initial_compilation_failed=initial_compile_failed,
            agent_trajectory={
                "messages": agent.messages,
                "exit_status": exit_status,
                "result": result,
                "cost": agent.model.cost,
                "n_calls": agent.model.n_calls,
            },
        )

        result_path = output_dir / f"{episode_id}.result.json"
        result_path.write_text(json.dumps(episode_result.to_dict(), indent=2))

        return episode_result

    finally:
        shutil.rmtree(workspace, ignore_errors=True)
