"""Security analysis tool wrappers for Slither and Aderyn.

Provides functions to run security tools and parse their JSON output
into a unified Finding dataclass.
"""

import json
from dataclasses import dataclass, field
from pathlib import Path

from vulnerability_injection.models import BugLocation


@dataclass
class Finding:
    """A security finding from a static analysis tool."""

    tool: str
    detector: str
    severity: str
    confidence: str
    description: str
    locations: list[BugLocation] = field(default_factory=list)

    def to_dict(self) -> dict:
        return {
            "tool": self.tool,
            "detector": self.detector,
            "severity": self.severity,
            "confidence": self.confidence,
            "description": self.description,
            "locations": [loc.to_dict() for loc in self.locations],
        }

    def matches_vulnerability(self, operator: str) -> bool:
        """Check if this finding matches a MuSe vulnerability operator."""
        operator_to_detectors = {
            "RE": ["reentrancy-eth", "reentrancy-no-eth", "reentrancy-benign", "reentrancy"],
            "TX": ["tx-origin", "tx-origin-auth"],
            "TD": ["timestamp", "block-timestamp", "weak-randomness"],
            "UC": ["unchecked-lowlevel", "low-level-calls"],
            "US": ["unchecked-send"],
            "UTR": ["unchecked-transfer"],
            "IUO": ["integer-overflow", "integer-underflow", "divide-before-multiply"],
            "USD": ["suicidal", "unprotected-selfdestruct", "unprotected-suicide"],
            "DTU": ["controlled-delegatecall", "delegatecall-loop"],
            "UR1": ["unused-return"],
            "UR2": ["unused-return"],
        }
        matching_detectors = operator_to_detectors.get(operator, [])
        return any(d in self.detector.lower() for d in matching_detectors)


@dataclass
class RewardSignal:
    """Reward signal computed from security analysis comparison."""

    vulnerability_fixed: bool
    new_vulns_introduced: int
    compilation_passed: bool
    total_reward: float
    details: dict = field(default_factory=dict)

    def to_dict(self) -> dict:
        return {
            "vulnerability_fixed": self.vulnerability_fixed,
            "new_vulns_introduced": self.new_vulns_introduced,
            "compilation_passed": self.compilation_passed,
            "total_reward": self.total_reward,
            "details": self.details,
        }


def parse_slither_json(json_output: str) -> list[Finding]:
    """Parse Slither JSON output into Finding objects.

    Args:
        json_output: Raw JSON string from slither --json -

    Returns:
        List of Finding objects
    """
    try:
        data = json.loads(json_output)
    except json.JSONDecodeError:
        return []

    findings = []
    detectors = data.get("results", {}).get("detectors", [])

    for detector in detectors:
        locations = []
        for element in detector.get("elements", []):
            source = element.get("source_mapping", {})
            lines = source.get("lines", [])
            if lines:
                locations.append(BugLocation(
                    file=source.get("filename_relative", ""),
                    start_line=min(lines),
                    end_line=max(lines),
                    start_char=source.get("start", 0),
                    end_char=source.get("start", 0) + source.get("length", 0),
                ))

        findings.append(Finding(
            tool="slither",
            detector=detector.get("check", "unknown"),
            severity=detector.get("impact", "Unknown"),
            confidence=detector.get("confidence", "Unknown"),
            description=detector.get("description", ""),
            locations=locations,
        ))

    return findings


def parse_aderyn_json(json_output: str) -> list[Finding]:
    """Parse Aderyn JSON output into Finding objects.

    Args:
        json_output: Raw JSON string from aderyn --output json

    Returns:
        List of Finding objects
    """
    try:
        data = json.loads(json_output)
    except json.JSONDecodeError:
        return []

    findings = []

    severity_map = {
        "high_issues": "High",
        "medium_issues": "Medium",
        "low_issues": "Low",
        "nc_issues": "Informational",
    }

    for issue_key, severity in severity_map.items():
        issues = data.get(issue_key, {}).get("issues", [])
        for issue in issues:
            locations = []
            for instance in issue.get("instances", []):
                src = instance.get("src", "")
                # Aderyn src format: "start:length:file_index"
                if src and ":" in src:
                    parts = src.split(":")
                    if len(parts) >= 2:
                        start = int(parts[0]) if parts[0].isdigit() else 0
                        length = int(parts[1]) if parts[1].isdigit() else 0
                        locations.append(BugLocation(
                            file=instance.get("contract_path", ""),
                            start_line=instance.get("line_no", 0),
                            end_line=instance.get("line_no", 0),
                            start_char=start,
                            end_char=start + length,
                        ))

            findings.append(Finding(
                tool="aderyn",
                detector=issue.get("title", "unknown"),
                severity=severity,
                confidence="High",
                description=issue.get("description", ""),
                locations=locations,
            ))

    return findings


def run_slither(
    contract_path: str,
    env,
    extra_args: str = "",
) -> tuple[list[Finding], str]:
    """Run Slither on a contract using the provided environment.

    Args:
        contract_path: Path to the contract (inside container)
        env: Environment with execute() method (FoundryEnvironment)
        extra_args: Additional arguments to pass to slither

    Returns:
        Tuple of (list of findings, raw output)
    """
    cmd = f". /opt/venv-main/bin/activate && slither {contract_path} --json - {extra_args} 2>/dev/null"
    result = env.execute(cmd)
    output = result.get("output", "")

    # Extract JSON from output (slither outputs JSON to stdout)
    try:
        json_start = output.find("{")
        json_end = output.rfind("}") + 1
        if json_start >= 0 and json_end > json_start:
            json_str = output[json_start:json_end]
            return parse_slither_json(json_str), output
    except Exception:
        pass

    return [], output


def run_aderyn(
    contract_path: str,
    env,
    output_file: str = "/tmp/aderyn_report.json",
) -> tuple[list[Finding], str]:
    """Run Aderyn on a contract using the provided environment.

    Args:
        contract_path: Path to the contract directory (inside container)
        env: Environment with execute() method (FoundryEnvironment)
        output_file: Path to write JSON report

    Returns:
        Tuple of (list of findings, raw output)
    """
    cmd = f"cd {contract_path} && aderyn . --output {output_file} 2>&1; cat {output_file}"
    result = env.execute(cmd)
    output = result.get("output", "")

    # Extract JSON from the cat output
    try:
        json_start = output.find("{")
        json_end = output.rfind("}") + 1
        if json_start >= 0 and json_end > json_start:
            json_str = output[json_start:json_end]
            return parse_aderyn_json(json_str), output
    except Exception:
        pass

    return [], output


def compare_findings(
    baseline: list[Finding],
    final: list[Finding],
    target_operator: str,
) -> RewardSignal:
    """Compare baseline and final findings to compute reward.

    Args:
        baseline: Findings from the mutated (vulnerable) contract
        final: Findings from the agent's fixed contract
        target_operator: The MuSe operator that was used to inject vulnerability

    Returns:
        RewardSignal with computed reward
    """
    # Check if the target vulnerability was fixed
    baseline_matches = [f for f in baseline if f.matches_vulnerability(target_operator)]
    final_matches = [f for f in final if f.matches_vulnerability(target_operator)]

    vulnerability_fixed = len(baseline_matches) > 0 and len(final_matches) == 0

    # Count new vulnerabilities (excluding the target type)
    baseline_other = {(f.detector, f.severity) for f in baseline if not f.matches_vulnerability(target_operator)}
    final_other = {(f.detector, f.severity) for f in final if not f.matches_vulnerability(target_operator)}
    new_vulns = final_other - baseline_other

    # Compute reward
    reward = 0.0
    if vulnerability_fixed:
        reward += 1.0

    # Penalty for new vulnerabilities
    reward -= 0.5 * len(new_vulns)

    return RewardSignal(
        vulnerability_fixed=vulnerability_fixed,
        new_vulns_introduced=len(new_vulns),
        compilation_passed=True,
        total_reward=reward,
        details={
            "baseline_target_findings": len(baseline_matches),
            "final_target_findings": len(final_matches),
            "new_vulnerabilities": list(new_vulns),
        },
    )

