"""Python wrapper for MuSe vulnerability injection tool."""

import json
import shutil
import subprocess
import tempfile
from pathlib import Path

from vulnerability_injection.models import (
    MuseMutation,
    VULNERABILITY_OPERATORS,
)

# Path to MuSe directory (relative to this file)
MUSE_DIR = Path(__file__).parent.parent / "MuSe"


class MuseInjector:
    """
    Python wrapper for MuSe vulnerability injection.

    MuSe is a Node.js-based mutation tool that injects vulnerabilities
    into Solidity smart contracts. This wrapper provides a Python API
    to invoke MuSe and parse its output.

    Example:
        >>> injector = MuseInjector()
        >>> mutations = injector.inject(Path("contract.sol"), Path("output/"))
        >>> for m in mutations:
        ...     print(f"{m.operator}: {m.original} -> {m.replacement}")
    """

    def __init__(
        self,
        operators: list[str] | None = None,
        muse_dir: Path | None = None,
        vulnerability_only: bool = True,
    ):
        """
        Initialize the MuSe injector.

        Args:
            operators: List of operator IDs to enable. If None, uses all
                      vulnerability operators (RE, TX, UC, etc.)
            muse_dir: Path to MuSe installation. Defaults to ./MuSe/
            vulnerability_only: If True and operators is None, only enable
                              vulnerability-specific operators (not general mutations)
        """
        self.muse_dir = muse_dir or MUSE_DIR
        self._verify_muse_installed()

        if operators is None:
            self.operators = VULNERABILITY_OPERATORS if vulnerability_only else None
        else:
            self.operators = operators

    def _verify_muse_installed(self):
        """Verify MuSe is installed and npm dependencies are available."""
        node_modules = self.muse_dir / "node_modules"
        if not node_modules.exists():
            raise RuntimeError(
                f"MuSe not installed. Run 'npm install' in {self.muse_dir}"
            )

    def _run_sumo(self, args: list[str], cwd: Path | None = None) -> subprocess.CompletedProcess:
        """Run sumo CLI command."""
        cmd = ["npx", "sumo"] + args
        return subprocess.run(
            cmd,
            cwd=cwd or self.muse_dir,
            capture_output=True,
            text=True,
        )

    def configure_operators(self, operators: list[str] | None = None):
        """
        Configure which operators are enabled in MuSe.

        Args:
            operators: List of operator IDs to enable. If None, enables all.
        """
        ops = operators or self.operators

        if ops is None:
            # Enable all operators
            return

        # Disable all first, then enable selected
        # Note: MuSe doesn't have a --all flag for disable, so we enable specific ones
        self._run_sumo(["enable"] + ops)

    def inject(
        self,
        contract_path: Path,
        output_dir: Path,
        operators: list[str] | None = None,
    ) -> list[MuseMutation]:
        """
        Inject vulnerabilities into a contract.

        Creates a temporary workspace, runs MuSe mutation, and copies
        results to the output directory.

        Args:
            contract_path: Path to the Solidity contract
            output_dir: Directory to save mutated contracts
            operators: Override operators for this injection only

        Returns:
            List of generated mutations with metadata
        """
        contract_path = Path(contract_path).resolve()
        output_dir = Path(output_dir).resolve()
        output_dir.mkdir(parents=True, exist_ok=True)

        if not contract_path.exists():
            raise FileNotFoundError(f"Contract not found: {contract_path}")

        # Create temporary workspace
        workspace = self._setup_workspace(contract_path)

        try:
            # Configure operators if specified
            if operators:
                self._run_sumo(["enable"] + operators, cwd=workspace)
            elif self.operators:
                self._run_sumo(["enable"] + self.operators, cwd=workspace)

            # Run mutation
            result = self._run_sumo(["mutate"], cwd=workspace)

            if result.returncode != 0:
                raise RuntimeError(f"MuSe mutate failed: {result.stderr}")

            # Parse results
            mutations_file = workspace / "sumo" / "results" / "mutations.json"
            mutations = self._parse_mutations(mutations_file, contract_path.name)

            # Copy mutants to output
            self._copy_mutants(workspace, output_dir, mutations)

            return mutations

        finally:
            # Cleanup workspace
            shutil.rmtree(workspace, ignore_errors=True)

    def _setup_workspace(self, contract_path: Path) -> Path:
        """
        Create a temporary workspace with the contract.

        Sets up a minimal project structure that MuSe can work with.
        """
        workspace = Path(tempfile.mkdtemp(prefix="muse_"))
        contracts_dir = workspace / "contracts"
        test_dir = workspace / "test"
        build_dir = workspace / "build"

        contracts_dir.mkdir()
        test_dir.mkdir()
        build_dir.mkdir()

        # Create a placeholder test file (MuSe requires at least one test file)
        (test_dir / "placeholder.js").write_text("// Placeholder test for MuSe mutation\n")

        # Copy contract
        shutil.copy(contract_path, contracts_dir / contract_path.name)

        # Copy sumo-config.js from MuSe dir or create one
        src_config = self.muse_dir / "sumo-config.js"
        if src_config.exists():
            shutil.copy(src_config, workspace / "sumo-config.js")
        else:
            # Create minimal config
            config_content = """module.exports = {
    buildDir: 'build',
    contractsDir: 'contracts',
    testDir: 'test',
    skipContracts: [],
    skipTests: [],
    testingTimeOutInSec: 300,
    network: "none",
    testingFramework: "forge",
    minimal: false,
    tce: false
}"""
            (workspace / "sumo-config.js").write_text(config_content)

        # Symlink node_modules to avoid reinstalling
        src_modules = self.muse_dir / "node_modules"
        if src_modules.exists():
            (workspace / "node_modules").symlink_to(src_modules)

        # Symlink src directory for operators
        src_src = self.muse_dir / "src"
        if src_src.exists():
            (workspace / "src").symlink_to(src_src)

        # Copy index.js for CLI
        src_index = self.muse_dir / "index.js"
        if src_index.exists():
            shutil.copy(src_index, workspace / "index.js")

        # Copy package.json
        src_pkg = self.muse_dir / "package.json"
        if src_pkg.exists():
            shutil.copy(src_pkg, workspace / "package.json")

        return workspace

    def _parse_mutations(
        self,
        mutations_file: Path,
        contract_name: str,
    ) -> list[MuseMutation]:
        """Parse MuSe mutations.json output."""
        if not mutations_file.exists():
            return []

        data = json.loads(mutations_file.read_text())

        mutations = []
        # MuSe groups mutations by contract filename
        for filename, file_mutations in data.items():
            if contract_name not in filename:
                continue
            for m in file_mutations:
                mutations.append(MuseMutation.from_muse_json(m))

        return mutations

    def _copy_mutants(
        self,
        workspace: Path,
        output_dir: Path,
        mutations: list[MuseMutation],
    ):
        """Copy generated mutant files to output directory."""
        mutants_dir = workspace / "sumo" / "results" / "mutants"
        if not mutants_dir.exists():
            return

        # Build a map of mutation ID to file
        mutant_files = {f.stem.split("-")[-1]: f for f in mutants_dir.glob("*.sol")}

        for mutation in mutations:
            mutant_id = mutation.id
            if mutant_id in mutant_files:
                src = mutant_files[mutant_id]
                dst = output_dir / src.name
                shutil.copy(src, dst)
                mutation.mutant_path = str(dst)

    def filter_vulnerability_mutations(
        self,
        mutations: list[MuseMutation],
    ) -> list[MuseMutation]:
        """
        Filter mutations to only include vulnerability-specific operators.

        Args:
            mutations: List of all mutations

        Returns:
            Filtered list containing only vulnerability mutations
        """
        return [m for m in mutations if m.operator in VULNERABILITY_OPERATORS]

    def list_operators(self) -> list[str]:
        """List all enabled operators in MuSe."""
        result = self._run_sumo(["list"])
        if result.returncode != 0:
            raise RuntimeError(f"Failed to list operators: {result.stderr}")
        return result.stdout


def inject_single_contract(
    contract_path: Path | str,
    output_dir: Path | str,
    operators: list[str] | None = None,
) -> list[MuseMutation]:
    """
    Convenience function to inject vulnerabilities into a single contract.

    Args:
        contract_path: Path to the Solidity contract
        output_dir: Directory to save mutated contracts
        operators: List of operator IDs to enable

    Returns:
        List of generated mutations
    """
    injector = MuseInjector(operators=operators)
    return injector.inject(Path(contract_path), Path(output_dir))
