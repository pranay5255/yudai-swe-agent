"""Data models for vulnerability injection."""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional


@dataclass
class BugLocation:
    """Precise location of an injected bug in source code."""

    file: str
    start_line: int
    end_line: int
    start_char: int
    end_char: int

    def to_dict(self) -> dict:
        return {
            "file": self.file,
            "start_line": self.start_line,
            "end_line": self.end_line,
            "start_char": self.start_char,
            "end_char": self.end_char,
        }


@dataclass
class MuseMutation:
    """A single mutation generated by MuSe."""

    id: str
    operator: str
    file: str
    start_line: int
    end_line: int
    start_char: int
    end_char: int
    original: str
    replacement: str
    status: Optional[str] = None
    testing_time: Optional[float] = None
    mutant_path: Optional[str] = None

    @property
    def location(self) -> BugLocation:
        """Get the bug location for this mutation."""
        return BugLocation(
            file=self.file,
            start_line=self.start_line,
            end_line=self.end_line,
            start_char=self.start_char,
            end_char=self.end_char,
        )

    @classmethod
    def from_muse_json(cls, data: dict, mutant_path: Optional[str] = None) -> "MuseMutation":
        """Create a MuseMutation from MuSe JSON output."""
        return cls(
            id=data["id"],
            operator=data["operator"],
            file=data["file"],
            start_line=data["startLine"],
            end_line=data["endLine"],
            start_char=data["start"],
            end_char=data["end"],
            original=data["original"],
            replacement=data["replace"],
            status=data.get("status"),
            testing_time=data.get("testingTime"),
            mutant_path=mutant_path,
        )

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "operator": self.operator,
            "file": self.file,
            "start_line": self.start_line,
            "end_line": self.end_line,
            "start_char": self.start_char,
            "end_char": self.end_char,
            "original": self.original,
            "replacement": self.replacement,
            "status": self.status,
            "testing_time": self.testing_time,
            "mutant_path": self.mutant_path,
        }


# Map MuSe operator IDs to human-readable names and metadata
OPERATOR_INFO = {
    "RE": {
        "name": "Reentrancy",
        "severity": "critical",
        "description": "Swaps state update and external call order",
        "detection_tools": ["slither", "mythril", "aderyn"],
    },
    "TX": {
        "name": "tx.origin Authentication",
        "severity": "high",
        "description": "Replaces msg.sender with tx.origin",
        "detection_tools": ["slither", "aderyn"],
    },
    "TD": {
        "name": "Timestamp Dependence",
        "severity": "medium",
        "description": "Replaces block properties with block.timestamp",
        "detection_tools": ["slither", "mythril"],
    },
    "UC": {
        "name": "Unchecked Call",
        "severity": "high",
        "description": "Removes require() from low-level calls",
        "detection_tools": ["slither", "aderyn"],
    },
    "US": {
        "name": "Unchecked Send",
        "severity": "high",
        "description": "Removes return check from .send()",
        "detection_tools": ["slither", "aderyn"],
    },
    "UTR": {
        "name": "Unchecked Transfer",
        "severity": "high",
        "description": "Removes check from token transfers",
        "detection_tools": ["slither", "aderyn"],
    },
    "IUO": {
        "name": "Integer Overflow/Underflow",
        "severity": "high",
        "description": "Removes SafeMath or adds unchecked blocks",
        "detection_tools": ["slither", "mythril"],
    },
    "USD": {
        "name": "Unprotected Selfdestruct",
        "severity": "critical",
        "description": "Changes visibility to public",
        "detection_tools": ["slither", "aderyn"],
    },
    "DTU": {
        "name": "Delegatecall to Untrusted",
        "severity": "critical",
        "description": "Replaces delegatecall target with controllable address",
        "detection_tools": ["slither", "aderyn"],
    },
    "UR1": {
        "name": "Unused Return (Assignment)",
        "severity": "medium",
        "description": "Ignores return value by default init",
        "detection_tools": ["slither"],
    },
    "UR2": {
        "name": "Unused Return (Declaration)",
        "severity": "medium",
        "description": "Ignores return in variable declaration",
        "detection_tools": ["slither"],
    },
}

# List of vulnerability-specific operators (vs general mutation operators)
VULNERABILITY_OPERATORS = list(OPERATOR_INFO.keys())


@dataclass
class BugMetadata:
    """Metadata about an injected vulnerability."""

    bug_type: str
    operator: str
    injector: str  # "muse" or "solidifi"
    location: BugLocation
    original_code: str
    vulnerable_code: str
    severity: str = "unknown"
    description: str = ""
    detection_tools: list[str] = field(default_factory=list)

    @classmethod
    def from_mutation(cls, mutation: MuseMutation, injector: str = "muse") -> "BugMetadata":
        """Create BugMetadata from a MuseMutation."""
        info = OPERATOR_INFO.get(mutation.operator, {})
        return cls(
            bug_type=info.get("name", mutation.operator),
            operator=mutation.operator,
            injector=injector,
            location=mutation.location,
            original_code=mutation.original,
            vulnerable_code=mutation.replacement,
            severity=info.get("severity", "unknown"),
            description=info.get("description", ""),
            detection_tools=info.get("detection_tools", []),
        )

    def to_dict(self) -> dict:
        return {
            "bug_type": self.bug_type,
            "operator": self.operator,
            "injector": self.injector,
            "location": self.location.to_dict(),
            "original_code": self.original_code,
            "vulnerable_code": self.vulnerable_code,
            "severity": self.severity,
            "description": self.description,
            "detection_tools": self.detection_tools,
        }


@dataclass
class TrainingPair:
    """A training pair consisting of original and vulnerable contracts."""

    id: str
    original_path: Path
    vulnerable_path: Path
    metadata: BugMetadata

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "original_path": str(self.original_path),
            "vulnerable_path": str(self.vulnerable_path),
            "metadata": self.metadata.to_dict(),
        }
