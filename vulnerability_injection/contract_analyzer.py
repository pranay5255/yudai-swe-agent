"""Contract analysis and dependency detection for Foundry project setup.

This module analyzes Solidity contracts to:
1. Detect Solidity version requirements
2. Identify external dependencies (OpenZeppelin, etc.)
3. Extract import statements
4. Classify contract complexity
"""

import re
from dataclasses import dataclass
from pathlib import Path


@dataclass
class ContractMetadata:
    """Metadata extracted from a Solidity contract."""

    solidity_version: str
    """Solidity version from pragma (e.g., '0.8.20', '0.4.26')"""

    pragma_range: str
    """Full pragma string (e.g., '^0.8.0', '>=0.4.22 <0.9.0')"""

    has_openzeppelin: bool
    """Whether contract imports OpenZeppelin"""

    oz_version: str | None
    """Detected OpenZeppelin version (v4, v5, etc.)"""

    imports: list[str]
    """List of all import statements"""

    external_contracts: list[str]
    """Names of contracts defined in external files that are referenced"""

    is_standalone: bool
    """True if contract has no external dependencies"""

    recommended_template: str
    """Recommended Foundry template to use"""

    needs_network: bool
    """True if contract likely needs a forked network (has external calls)"""


def extract_solidity_version(content: str) -> tuple[str, str]:
    """Extract Solidity version from pragma statement.

    Args:
        content: Contract source code

    Returns:
        Tuple of (version, pragma_range)
        - version: Concrete version like '0.8.20' or '0.4.26'
        - pragma_range: Original pragma like '^0.8.0'
    """
    # Match: pragma solidity ^0.8.0; or pragma solidity >=0.4.22 <0.9.0;
    pragma_match = re.search(r"pragma\s+solidity\s+([^;]+);", content)
    if not pragma_match:
        return "0.8.24", "^0.8.0"  # Default to latest

    pragma_range = pragma_match.group(1).strip()

    # Extract concrete version from pragma
    # Examples:
    # '^0.8.0' -> '0.8.0'
    # '>=0.4.22 <0.9.0' -> '0.4.26' (pick reasonable middle version)
    # '0.8.20' -> '0.8.20'

    if "^" in pragma_range:
        # ^0.8.0 -> 0.8.0
        version = pragma_range.replace("^", "")
    elif ">=" in pragma_range and "<" in pragma_range:
        # >=0.4.22 <0.9.0 -> pick 0.4.26 for 0.4.x, 0.8.20 for 0.8.x
        lower_match = re.search(r">=\s*([0-9.]+)", pragma_range)
        if lower_match:
            lower = lower_match.group(1)
            major_minor = ".".join(lower.split(".")[:2])
            # Map to reasonable patch versions
            version_map = {
                "0.4": "0.4.26",
                "0.5": "0.5.17",
                "0.6": "0.6.12",
                "0.7": "0.7.6",
                "0.8": "0.8.20",
            }
            version = version_map.get(major_minor, lower)
        else:
            version = "0.8.20"
    else:
        # Assume it's already a concrete version
        version = pragma_range

    return version, pragma_range


def detect_openzeppelin_version(content: str, imports: list[str]) -> str | None:
    """Detect OpenZeppelin version from import paths.

    Args:
        content: Contract source code
        imports: List of import statements

    Returns:
        Version string like 'v4' or 'v5', or None if no OZ imports
    """
    oz_imports = [imp for imp in imports if "openzeppelin" in imp.lower()]
    if not oz_imports:
        return None

    # Try to detect version from import path structure
    # v5: import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    # v4: Same structure but different contract interfaces
    # Heuristic: check for v5-specific patterns

    # Check for IERC20.permit (introduced in v5)
    if "IERC20Permit" in content or re.search(r"permit\s*\(", content):
        return "v5"

    # Check for old patterns (before v4.0)
    if "@openzeppelin/contracts-ethereum-package" in content:
        return "v3"

    # Default to v4 (most common)
    return "v4"


def extract_imports(content: str) -> list[str]:
    """Extract all import statements from contract.

    Args:
        content: Contract source code

    Returns:
        List of import paths
    """
    # Match: import "path"; or import {A, B} from "path";
    import_pattern = re.compile(
        r'import\s+(?:\{[^}]*\}\s+from\s+)?["\']([^"\']+)["\']', re.MULTILINE
    )
    return import_pattern.findall(content)


def detect_external_contracts(content: str) -> list[str]:
    """Detect references to external contracts that may need stubs.

    Args:
        content: Contract source code

    Returns:
        List of external contract names
    """
    external_contracts = []

    # Find contract declarations
    contract_pattern = re.compile(r"contract\s+(\w+)", re.MULTILINE)
    declared_contracts = set(contract_pattern.findall(content))

    # Find contract instantiations/references
    # Pattern: SomeContract variable or SomeContract(address)
    reference_pattern = re.compile(r"\b([A-Z][a-zA-Z0-9]*)\s*\(", re.MULTILINE)
    referenced = set(reference_pattern.findall(content))

    # Also check for explicit type declarations
    type_pattern = re.compile(r"\b([A-Z][a-zA-Z0-9]*)\s+\w+\s*[;=]", re.MULTILINE)
    typed = set(type_pattern.findall(content))

    # External contracts are referenced but not declared
    potential_external = (referenced | typed) - declared_contracts

    # Filter out common keywords
    keywords = {
        "Ownable",
        "ERC20",
        "ERC721",
        "SafeMath",
        "Address",
        "String",
        "Math",
        "Arrays",
    }
    external_contracts = list(potential_external - keywords)

    return external_contracts


def check_needs_network(content: str) -> bool:
    """Check if contract likely needs a forked network for testing.

    Args:
        content: Contract source code

    Returns:
        True if contract makes external calls to mainnet contracts
    """
    # Check for patterns that suggest external protocol interaction
    patterns = [
        r"Uniswap",  # DEX interaction
        r"IUniswap",
        r"Chainlink",  # Oracle
        r"AggregatorV3Interface",
        r"\.call\{value:",  # ETH transfers
        r"WETH",  # Wrapped ETH
        r"0x[0-9a-fA-F]{40}",  # Hardcoded addresses
    ]

    for pattern in patterns:
        if re.search(pattern, content):
            return True

    return False


def analyze_contract(contract_path: Path) -> ContractMetadata:
    """Analyze a Solidity contract and extract metadata.

    Args:
        contract_path: Path to .sol file

    Returns:
        ContractMetadata with analysis results
    """
    content = contract_path.read_text()

    # Extract version
    version, pragma_range = extract_solidity_version(content)

    # Extract imports
    imports = extract_imports(content)

    # Check for OpenZeppelin
    has_openzeppelin = any("openzeppelin" in imp.lower() for imp in imports)
    oz_version = detect_openzeppelin_version(content, imports) if has_openzeppelin else None

    # Detect external contracts
    external_contracts = detect_external_contracts(content)

    # Check if standalone
    is_standalone = not has_openzeppelin and not imports and not external_contracts

    # Determine recommended template
    if version.startswith("0.4"):
        template = "sol-0.4-standalone"
    elif version.startswith("0.5"):
        template = "sol-0.5-standalone"
    elif has_openzeppelin:
        template = f"sol-0.8-oz-{oz_version}" if oz_version else "sol-0.8-oz-v4"
    else:
        template = "sol-0.8-standalone"

    # Check if needs network fork
    needs_network = check_needs_network(content)

    return ContractMetadata(
        solidity_version=version,
        pragma_range=pragma_range,
        has_openzeppelin=has_openzeppelin,
        oz_version=oz_version,
        imports=imports,
        external_contracts=external_contracts,
        is_standalone=is_standalone,
        recommended_template=template,
        needs_network=needs_network,
    )


def generate_foundry_toml(metadata: ContractMetadata) -> str:
    """Generate foundry.toml content based on metadata.

    Args:
        metadata: Contract metadata

    Returns:
        foundry.toml content as string
    """
    config = f"""[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc = "{metadata.solidity_version}"

[profile.default.optimizer]
enabled = true
runs = 200
"""

    # Add remappings if OpenZeppelin
    if metadata.has_openzeppelin:
        config += """
[profile.default.remappings]
"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/"
"""

    # Add EVM version if old Solidity
    if metadata.solidity_version.startswith("0.4") or metadata.solidity_version.startswith(
        "0.5"
    ):
        config += """
[profile.default.evm_version]
evm_version = "istanbul"
"""

    return config


if __name__ == "__main__":
    # Test the analyzer
    import sys

    if len(sys.argv) < 2:
        print("Usage: python contract_analyzer.py <contract.sol>")
        sys.exit(1)

    contract = Path(sys.argv[1])
    if not contract.exists():
        print(f"Contract not found: {contract}")
        sys.exit(1)

    metadata = analyze_contract(contract)

    print(f"Contract Analysis: {contract.name}")
    print("=" * 50)
    print(f"Solidity Version: {metadata.solidity_version}")
    print(f"Pragma: {metadata.pragma_range}")
    print(f"OpenZeppelin: {metadata.has_openzeppelin} ({metadata.oz_version or 'N/A'})")
    print(f"Imports: {len(metadata.imports)}")
    for imp in metadata.imports:
        print(f"  - {imp}")
    print(f"External Contracts: {metadata.external_contracts}")
    print(f"Standalone: {metadata.is_standalone}")
    print(f"Needs Network: {metadata.needs_network}")
    print(f"Recommended Template: {metadata.recommended_template}")
    print("\nGenerated foundry.toml:")
    print("-" * 50)
    print(generate_foundry_toml(metadata))
