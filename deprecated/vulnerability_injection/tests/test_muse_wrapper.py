"""Tests for MuSe wrapper."""

import json
import pytest
from pathlib import Path
import tempfile
import shutil

from vulnerability_injection.models import (
    MuseMutation,
    BugMetadata,
    BugLocation,
    VULNERABILITY_OPERATORS,
    OPERATOR_INFO,
)
from vulnerability_injection.muse_wrapper import MuseInjector, MUSE_DIR


# Sample contract for testing
SAMPLE_CONTRACT = '''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract TestVault {
    mapping(address => uint256) public balances;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient");
        balances[msg.sender] -= amount;
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Failed");
    }

    function setOwner(address newOwner) external onlyOwner {
        owner = newOwner;
    }
}
'''


class TestMuseMutation:
    """Tests for MuseMutation dataclass."""

    def test_from_muse_json(self):
        """Test parsing MuSe JSON format."""
        data = {
            "id": "m46f345c9",
            "operator": "RE",
            "file": "/path/to/contract.sol",
            "start": 100,
            "end": 200,
            "startLine": 10,
            "endLine": 12,
            "original": "balances[msg.sender] -= amount;",
            "replace": "msg.sender.call{value: amount}('');",
            "status": None,
            "testingTime": None,
        }
        mutation = MuseMutation.from_muse_json(data)

        assert mutation.id == "m46f345c9"
        assert mutation.operator == "RE"
        assert mutation.start_line == 10
        assert mutation.end_line == 12
        assert mutation.original == "balances[msg.sender] -= amount;"

    def test_location_property(self):
        """Test BugLocation extraction."""
        mutation = MuseMutation(
            id="test",
            operator="TX",
            file="test.sol",
            start_line=5,
            end_line=5,
            start_char=10,
            end_char=20,
            original="msg.sender",
            replacement="tx.origin",
        )
        loc = mutation.location

        assert isinstance(loc, BugLocation)
        assert loc.start_line == 5
        assert loc.file == "test.sol"

    def test_to_dict(self):
        """Test serialization to dict."""
        mutation = MuseMutation(
            id="test",
            operator="UC",
            file="test.sol",
            start_line=1,
            end_line=1,
            start_char=0,
            end_char=10,
            original="require()",
            replacement="",
        )
        d = mutation.to_dict()

        assert d["id"] == "test"
        assert d["operator"] == "UC"
        assert "start_line" in d


class TestBugMetadata:
    """Tests for BugMetadata dataclass."""

    def test_from_mutation(self):
        """Test creating BugMetadata from MuseMutation."""
        mutation = MuseMutation(
            id="test",
            operator="RE",
            file="test.sol",
            start_line=10,
            end_line=12,
            start_char=100,
            end_char=200,
            original="state -= amount; call();",
            replacement="call(); state -= amount;",
        )
        metadata = BugMetadata.from_mutation(mutation)

        assert metadata.bug_type == "Reentrancy"
        assert metadata.operator == "RE"
        assert metadata.severity == "critical"
        assert "slither" in metadata.detection_tools

    def test_unknown_operator(self):
        """Test handling of unknown operators."""
        mutation = MuseMutation(
            id="test",
            operator="UNKNOWN",
            file="test.sol",
            start_line=1,
            end_line=1,
            start_char=0,
            end_char=10,
            original="foo",
            replacement="bar",
        )
        metadata = BugMetadata.from_mutation(mutation)

        assert metadata.bug_type == "UNKNOWN"
        assert metadata.severity == "unknown"


class TestOperatorInfo:
    """Tests for operator configuration."""

    def test_all_operators_have_info(self):
        """Verify all vulnerability operators have metadata."""
        for op in VULNERABILITY_OPERATORS:
            assert op in OPERATOR_INFO, f"Missing info for operator {op}"
            info = OPERATOR_INFO[op]
            assert "name" in info
            assert "severity" in info
            assert "detection_tools" in info


@pytest.fixture
def sample_contract_path():
    """Create a temporary contract file for testing."""
    with tempfile.NamedTemporaryFile(
        mode="w",
        suffix=".sol",
        delete=False,
    ) as f:
        f.write(SAMPLE_CONTRACT)
        path = Path(f.name)

    yield path

    # Cleanup
    path.unlink(missing_ok=True)


@pytest.fixture
def output_dir():
    """Create a temporary output directory."""
    d = Path(tempfile.mkdtemp(prefix="muse_test_"))
    yield d
    shutil.rmtree(d, ignore_errors=True)


class TestMuseInjector:
    """Tests for MuseInjector class."""

    @pytest.mark.skipif(
        not (MUSE_DIR / "node_modules").exists(),
        reason="MuSe not installed",
    )
    def test_injector_init(self):
        """Test injector initialization."""
        injector = MuseInjector()
        assert injector.operators == VULNERABILITY_OPERATORS

    @pytest.mark.skipif(
        not (MUSE_DIR / "node_modules").exists(),
        reason="MuSe not installed",
    )
    def test_injector_custom_operators(self):
        """Test injector with custom operators."""
        injector = MuseInjector(operators=["RE", "TX"])
        assert injector.operators == ["RE", "TX"]

    @pytest.mark.skipif(
        not (MUSE_DIR / "node_modules").exists(),
        reason="MuSe not installed",
    )
    def test_inject_contract(self, sample_contract_path, output_dir):
        """Test full injection workflow."""
        injector = MuseInjector()
        mutations = injector.inject(sample_contract_path, output_dir)

        # Should generate some mutations
        assert len(mutations) > 0

        # Check output directory has mutants
        mutant_files = list(output_dir.glob("*.sol"))
        assert len(mutant_files) > 0

    @pytest.mark.skipif(
        not (MUSE_DIR / "node_modules").exists(),
        reason="MuSe not installed",
    )
    def test_filter_vulnerability_mutations(self, sample_contract_path, output_dir):
        """Test filtering to vulnerability-only mutations."""
        injector = MuseInjector(vulnerability_only=False)
        all_mutations = injector.inject(sample_contract_path, output_dir)

        vuln_mutations = injector.filter_vulnerability_mutations(all_mutations)

        # Vulnerability mutations should be a subset
        assert len(vuln_mutations) <= len(all_mutations)
        for m in vuln_mutations:
            assert m.operator in VULNERABILITY_OPERATORS

    def test_missing_muse_raises(self):
        """Test that missing MuSe installation raises error."""
        with pytest.raises(RuntimeError, match="MuSe not installed"):
            MuseInjector(muse_dir=Path("/nonexistent"))

    def test_missing_contract_raises(self, output_dir):
        """Test that missing contract raises error."""
        if not (MUSE_DIR / "node_modules").exists():
            pytest.skip("MuSe not installed")

        injector = MuseInjector()
        with pytest.raises(FileNotFoundError):
            injector.inject(Path("/nonexistent.sol"), output_dir)
