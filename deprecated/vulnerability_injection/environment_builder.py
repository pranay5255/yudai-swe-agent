"""Environment builder for creating compilation-ready Foundry projects.

This module creates complete Foundry projects with all dependencies resolved
BEFORE the agent starts execution. Based on SCONE-bench's approach adapted
for vulnerability fixing.
"""

import json
import logging
import shutil
import subprocess
import tempfile
from dataclasses import dataclass
from pathlib import Path

from vulnerability_injection.contract_analyzer import ContractMetadata, analyze_contract


@dataclass
class BuildResult:
    """Result of building a Foundry environment."""

    success: bool
    """Whether the build succeeded"""

    workspace: Path
    """Path to the created workspace"""

    metadata: ContractMetadata
    """Contract metadata"""

    errors: list[str]
    """List of errors encountered"""

    template_used: str
    """Template that was used"""

    compilation_output: str
    """Output from forge build attempt"""

    docker_image: str | None = None
    """Docker image selected for this environment"""


logger = logging.getLogger(__name__)


# Mapping of templates to specialized Docker images
TEMPLATE_TO_IMAGE = {
    "sol-0.4-standalone": "yudai-sol-0.4-standalone:latest",
    "sol-0.5-standalone": "yudai-sol-0.8-standalone:latest",  # Fallback to 0.8
    "sol-0.8-standalone": "yudai-sol-0.8-standalone:latest",
    "sol-0.8-oz-v3": "yudai-sol-0.8-oz-v4:latest",  # Fallback to v4
    "sol-0.8-oz-v4": "yudai-sol-0.8-oz-v4:latest",
    "sol-0.8-oz-v5": "yudai-sol-0.8-oz-v5:latest",
    "minimal": "yudai-base:latest",
}


class EnvironmentBuilder:
    """Builder for creating compilation-ready Foundry environments."""

    def __init__(
        self,
        templates_dir: Path | None = None,
        use_docker: bool = False,
        docker_image: str | None = None,
        auto_select_image: bool = True,
    ):
        """Initialize environment builder.

        Args:
            templates_dir: Directory containing Foundry templates
            use_docker: Whether to use Docker for compilation tests
            docker_image: Docker image to use if use_docker=True
            auto_select_image: Auto-select specialized Docker image based on contract
        """
        self.templates_dir = templates_dir or Path("/templates")
        self.use_docker = use_docker
        self.docker_image = docker_image or "yudai-complete:latest"
        self.auto_select_image = auto_select_image

    def create_minimal_template(self, workspace: Path, metadata: ContractMetadata) -> None:
        """Create a minimal Foundry project from scratch.

        Args:
            workspace: Directory to create project in
            metadata: Contract metadata to configure project
        """
        workspace.mkdir(parents=True, exist_ok=True)

        # Create directory structure
        (workspace / "src").mkdir(exist_ok=True)
        (workspace / "test").mkdir(exist_ok=True)
        (workspace / "lib").mkdir(exist_ok=True)
        (workspace / "script").mkdir(exist_ok=True)

        # Generate foundry.toml
        from vulnerability_injection.contract_analyzer import generate_foundry_toml

        foundry_toml = generate_foundry_toml(metadata)
        (workspace / "foundry.toml").write_text(foundry_toml)

        # Create .gitignore
        gitignore = """# Foundry
cache/
out/
broadcast/

# IDE
.vscode/
.idea/
*.swp
*.swo
"""
        (workspace / ".gitignore").write_text(gitignore)

        logger.info(f"Created minimal Foundry project at {workspace}")

    def install_dependencies(
        self, workspace: Path, metadata: ContractMetadata
    ) -> tuple[bool, str]:
        """Install required dependencies using forge install.

        Args:
            workspace: Foundry project directory
            metadata: Contract metadata

        Returns:
            Tuple of (success, output)
        """
        if not metadata.has_openzeppelin:
            return True, "No dependencies to install"

        # Determine OpenZeppelin version
        oz_version_map = {
            "v3": "v3.4.2",
            "v4": "v4.9.6",
            "v5": "v5.0.2",
        }
        oz_tag = oz_version_map.get(metadata.oz_version or "v4", "v4.9.6")

        logger.info(f"Installing OpenZeppelin {oz_tag}...")

        try:
            # Run forge install
            result = subprocess.run(
                [
                    "forge",
                    "install",
                    f"OpenZeppelin/openzeppelin-contracts@{oz_tag}",
                    "--no-commit",
                ],
                cwd=workspace,
                capture_output=True,
                text=True,
                timeout=120,
            )

            if result.returncode != 0:
                logger.error(f"Failed to install OpenZeppelin: {result.stderr}")
                return False, result.stderr

            logger.info("OpenZeppelin installed successfully")
            return True, result.stdout

        except subprocess.TimeoutExpired:
            return False, "Timeout installing dependencies"
        except Exception as e:
            return False, str(e)

    def create_stub_contracts(self, workspace: Path, metadata: ContractMetadata) -> None:
        """Create stub contracts for external dependencies.

        Args:
            workspace: Foundry project directory
            metadata: Contract metadata
        """
        if not metadata.external_contracts:
            return

        logger.info(f"Creating stubs for: {metadata.external_contracts}")

        stubs_dir = workspace / "src" / "stubs"
        stubs_dir.mkdir(exist_ok=True)

        for contract_name in metadata.external_contracts:
            # Create minimal stub contract
            stub_content = f"""// SPDX-License-Identifier: MIT
pragma solidity {metadata.pragma_range};

/**
 * Stub contract for {contract_name}
 * Auto-generated to satisfy compilation dependencies
 */
contract {contract_name} {{
    // Minimal implementation
    function placeholder() public pure returns (bool) {{
        return true;
    }}
}}
"""
            stub_path = stubs_dir / f"{contract_name}.sol"
            stub_path.write_text(stub_content)
            logger.info(f"Created stub: {stub_path}")

    def try_compile(
        self, workspace: Path, use_docker: bool = False
    ) -> tuple[bool, str]:
        """Attempt to compile the Foundry project.

        Args:
            workspace: Foundry project directory
            use_docker: Use Docker for compilation

        Returns:
            Tuple of (success, output)
        """
        if use_docker:
            return self._compile_in_docker(workspace)
        else:
            return self._compile_locally(workspace)

    def _compile_locally(self, workspace: Path) -> tuple[bool, str]:
        """Compile using local forge installation.

        Args:
            workspace: Foundry project directory

        Returns:
            Tuple of (success, output)
        """
        try:
            result = subprocess.run(
                ["forge", "build", "--force"],
                cwd=workspace,
                capture_output=True,
                text=True,
                timeout=180,
            )

            success = result.returncode == 0
            output = result.stdout + "\n" + result.stderr

            if success:
                logger.info("Compilation successful ✓")
            else:
                logger.warning(f"Compilation failed: {result.stderr[:500]}")

            return success, output

        except subprocess.TimeoutExpired:
            return False, "Compilation timeout"
        except FileNotFoundError:
            return False, "forge command not found. Install Foundry: https://getfoundry.sh"
        except Exception as e:
            return False, str(e)

    def _extract_template_from_image(
        self, image: str, template_name: str, dest: Path
    ) -> bool:
        """Extract a pre-built template from a Docker image.

        Args:
            image: Docker image name
            template_name: Template name (e.g., "sol-0.8-oz-v4")
            dest: Destination directory

        Returns:
            True if extraction succeeded
        """
        try:
            # Create temporary container and copy template
            container_path = f"/templates/{template_name}"

            # Use docker cp to extract template
            # First create a temporary container
            result = subprocess.run(
                ["docker", "create", image],
                capture_output=True,
                text=True,
                timeout=30,
            )

            if result.returncode != 0:
                logger.error(f"Failed to create container: {result.stderr}")
                return False

            container_id = result.stdout.strip()

            try:
                # Copy template from container
                result = subprocess.run(
                    ["docker", "cp", f"{container_id}:{container_path}/.", str(dest)],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )

                if result.returncode != 0:
                    logger.error(f"Failed to copy template: {result.stderr}")
                    return False

                logger.info(f"✓ Extracted template from {image}")
                return True

            finally:
                # Clean up container
                subprocess.run(
                    ["docker", "rm", container_id],
                    capture_output=True,
                    timeout=30,
                )

        except subprocess.TimeoutExpired:
            logger.error("Timeout extracting template from Docker")
            return False
        except Exception as e:
            logger.error(f"Exception extracting template: {e}")
            return False

    def _compile_in_docker(self, workspace: Path) -> tuple[bool, str]:
        """Compile using Docker container.

        Args:
            workspace: Foundry project directory

        Returns:
            Tuple of (success, output)
        """
        try:
            result = subprocess.run(
                [
                    "docker",
                    "run",
                    "--rm",
                    "-v",
                    f"{workspace}:/workspace",
                    self.docker_image,
                    "forge",
                    "build",
                    "--force",
                ],
                capture_output=True,
                text=True,
                timeout=180,
            )

            success = result.returncode == 0
            output = result.stdout + "\n" + result.stderr

            if success:
                logger.info("Docker compilation successful ✓")
            else:
                logger.warning(f"Docker compilation failed: {result.stderr[:500]}")

            return success, output

        except Exception as e:
            return False, str(e)

    def select_docker_image(self, metadata: ContractMetadata) -> str:
        """Select appropriate Docker image based on contract metadata.

        Args:
            metadata: Contract metadata from analysis

        Returns:
            Docker image name
        """
        if not self.auto_select_image:
            return self.docker_image

        # Map template to specialized image
        template = metadata.recommended_template
        image = TEMPLATE_TO_IMAGE.get(template, self.docker_image)

        logger.info(f"Selected Docker image: {image} (for template: {template})")
        return image

    def build_environment(
        self, contract_path: Path, output_dir: Path | None = None
    ) -> BuildResult:
        """Build a complete, compilation-ready Foundry environment.

        This is the main entry point that orchestrates the entire build process.

        Args:
            contract_path: Path to the Solidity contract
            output_dir: Directory to create workspace in (temp dir if None)

        Returns:
            BuildResult with workspace path and status
        """
        errors = []

        # Step 1: Analyze contract
        logger.info(f"Analyzing contract: {contract_path.name}")
        try:
            metadata = analyze_contract(contract_path)
            logger.info(f"  Version: {metadata.solidity_version}")
            logger.info(f"  Template: {metadata.recommended_template}")
            logger.info(f"  OpenZeppelin: {metadata.has_openzeppelin} ({metadata.oz_version})")
        except Exception as e:
            logger.error(f"Failed to analyze contract: {e}")
            return BuildResult(
                success=False,
                workspace=Path(),
                metadata=None,
                errors=[f"Analysis failed: {e}"],
                template_used="none",
                compilation_output="",
                docker_image=None,
            )

        # Step 2: Create workspace
        if output_dir:
            workspace = output_dir
            workspace.mkdir(parents=True, exist_ok=True)
        else:
            workspace = Path(tempfile.mkdtemp(prefix="foundry_env_"))

        logger.info(f"Creating workspace at: {workspace}")

        # Step 3: Select appropriate Docker image (if auto-select enabled)
        selected_image = self.select_docker_image(metadata)

        # Step 4: Try template first (if available)
        template_path = self.templates_dir / metadata.recommended_template
        template_used = "minimal"

        # Try copying from Docker image if using specialized images
        if (
            self.use_docker
            and self.auto_select_image
            and selected_image != self.docker_image
        ):
            logger.info(f"Extracting template from Docker image: {selected_image}")
            if self._extract_template_from_image(
                selected_image, metadata.recommended_template, workspace
            ):
                template_used = metadata.recommended_template
            else:
                logger.warning("Failed to extract from Docker, trying local template")
                if template_path.exists():
                    shutil.copytree(template_path, workspace, dirs_exist_ok=True)
                    template_used = metadata.recommended_template
                else:
                    self.create_minimal_template(workspace, metadata)
        elif template_path.exists():
            logger.info(f"Using local template: {metadata.recommended_template}")
            try:
                shutil.copytree(template_path, workspace, dirs_exist_ok=True)
                template_used = metadata.recommended_template
            except Exception as e:
                logger.warning(f"Failed to copy template: {e}, creating minimal")
                self.create_minimal_template(workspace, metadata)
        else:
            logger.info("No template available, creating minimal project")
            self.create_minimal_template(workspace, metadata)

        # Step 4: Install dependencies
        if metadata.has_openzeppelin:
            success, output = self.install_dependencies(workspace, metadata)
            if not success:
                errors.append(f"Dependency installation failed: {output}")
                # Continue anyway, might still work

        # Step 5: Create stubs for external contracts
        if metadata.external_contracts:
            try:
                self.create_stub_contracts(workspace, metadata)
            except Exception as e:
                errors.append(f"Failed to create stubs: {e}")

        # Step 6: Copy contract to src/
        try:
            shutil.copy(contract_path, workspace / "src" / contract_path.name)
            logger.info(f"Copied contract to: {workspace / 'src' / contract_path.name}")
        except Exception as e:
            errors.append(f"Failed to copy contract: {e}")
            return BuildResult(
                success=False,
                workspace=workspace,
                metadata=metadata,
                errors=errors,
                template_used=template_used,
                compilation_output="",
                docker_image=selected_image,
            )

        # Step 7: Save metadata for agent
        metadata_file = workspace / ".contract_metadata.json"
        metadata_file.write_text(
            json.dumps(
                {
                    "contract_name": contract_path.name,
                    "solidity_version": metadata.solidity_version,
                    "has_openzeppelin": metadata.has_openzeppelin,
                    "oz_version": metadata.oz_version,
                    "imports": metadata.imports,
                    "external_contracts": metadata.external_contracts,
                    "is_standalone": metadata.is_standalone,
                    "needs_network": metadata.needs_network,
                },
                indent=2,
            )
        )

        # Step 8: Verify compilation
        logger.info("Verifying compilation...")
        compile_success, compile_output = self.try_compile(workspace, self.use_docker)

        if not compile_success:
            errors.append("Initial compilation failed")
            logger.error("❌ Environment build failed - compilation error")
        else:
            logger.info("✓ Environment build successful - contract compiles!")

        return BuildResult(
            success=compile_success,
            workspace=workspace,
            metadata=metadata,
            errors=errors,
            template_used=template_used,
            compilation_output=compile_output,
            docker_image=selected_image,
        )


def build_environment_for_contract(
    contract_path: Path,
    output_dir: Path | None = None,
    use_docker: bool = False,
) -> BuildResult:
    """Convenience function to build environment for a contract.

    Args:
        contract_path: Path to Solidity contract
        output_dir: Output directory (temp if None)
        use_docker: Whether to use Docker for compilation

    Returns:
        BuildResult
    """
    builder = EnvironmentBuilder(use_docker=use_docker)
    return builder.build_environment(contract_path, output_dir)


if __name__ == "__main__":
    # Test the builder
    import sys

    logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

    if len(sys.argv) < 2:
        print("Usage: python environment_builder.py <contract.sol>")
        sys.exit(1)

    contract = Path(sys.argv[1])
    if not contract.exists():
        print(f"Contract not found: {contract}")
        sys.exit(1)

    print(f"Building environment for: {contract.name}")
    print("=" * 60)

    result = build_environment_for_contract(contract, use_docker=False)

    print("\nBuild Result:")
    print(f"  Success: {result.success}")
    print(f"  Workspace: {result.workspace}")
    print(f"  Template: {result.template_used}")
    print(f"  Errors: {len(result.errors)}")
    for error in result.errors:
        print(f"    - {error}")

    if result.success:
        print("\n✓ Environment is ready for agent!")
        print(f"\nTo test manually:")
        print(f"  cd {result.workspace}")
        print(f"  forge build")
    else:
        print("\n❌ Environment build failed")
        print("\nCompilation output:")
        print(result.compilation_output[:1000])
