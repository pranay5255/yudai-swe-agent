"""Parse and format Forge script traces for exploit generation."""

from __future__ import annotations

import re
from typing import Iterable

from exploit_generation.models import ExecutionTrace


_TRACE_HEADER = re.compile(r"^\s*Traces?:\s*$", re.IGNORECASE)
_REVERT_REASON = re.compile(
    r"(?:revert(?:ed)?|error)\s*(?:with reason string)?[:\s]+\"?([^\"\n]+)\"?",
    re.IGNORECASE,
)
_GAS_USED = re.compile(r"gas used:\s*([0-9_]+)", re.IGNORECASE)
_STATE_CHANGE_HINT = re.compile(
    r"(storage|state|sstore|sload|slot|balance|diff)",
    re.IGNORECASE,
)


def parse_forge_script_output(output: str, returncode: int) -> ExecutionTrace:
    """Parse forge script output into a structured trace."""
    trace_lines = _extract_trace_lines(output)
    revert_reason = _extract_revert_reason(output)
    gas_used = _extract_gas_used(output)
    internal_calls, state_changes = _split_trace_lines(trace_lines)

    success = returncode == 0 and not revert_reason

    return ExecutionTrace(
        success=success,
        revert_reason=revert_reason,
        gas_used=gas_used,
        state_changes=state_changes,
        internal_calls=internal_calls,
        raw_output=output,
    )


def format_trace_for_llm(trace: ExecutionTrace) -> str:
    """Format a parsed trace into LLM-friendly text."""
    lines = [f"forge script: {'success' if trace.success else 'failed'}"]
    if trace.revert_reason:
        lines.append(f"revert_reason: {trace.revert_reason}")
    if trace.gas_used:
        lines.append(f"gas_used: {trace.gas_used}")

    if trace.internal_calls:
        lines.append("internal_calls:")
        lines.extend(_render_items(trace.internal_calls))

    if trace.state_changes:
        lines.append("state_changes:")
        lines.extend(_render_items(trace.state_changes))

    return "\n".join(lines)


def _extract_trace_lines(output: str) -> list[str]:
    lines = output.splitlines()
    for idx, line in enumerate(lines):
        if _TRACE_HEADER.match(line.strip()):
            return [ln.rstrip() for ln in lines[idx + 1 :]]
    return []


def _extract_revert_reason(output: str) -> str | None:
    for line in output.splitlines():
        match = _REVERT_REASON.search(line)
        if match:
            return match.group(1).strip()
    return None


def _extract_gas_used(output: str) -> int:
    match = _GAS_USED.search(output)
    if not match:
        return 0
    return int(match.group(1).replace("_", ""))


def _split_trace_lines(lines: Iterable[str]) -> tuple[list[dict], list[dict]]:
    internal_calls: list[dict] = []
    state_changes: list[dict] = []

    for raw in lines:
        line = raw.strip()
        if not line:
            continue
        internal_calls.append({"raw": line})

        if _STATE_CHANGE_HINT.search(line):
            state_changes.append({"raw": line})

    return internal_calls, state_changes


def _render_items(items: Iterable[dict]) -> list[str]:
    rendered = []
    for item in items:
        if isinstance(item, dict):
            raw = item.get("raw")
            if raw:
                rendered.append(str(raw))
        else:
            rendered.append(str(item))
    return rendered
