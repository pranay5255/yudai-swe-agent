"""Fetch smart contract source code from block explorers (Etherscan, BscScan, BaseScan)."""

import json
import os
import time
from dataclasses import dataclass
from pathlib import Path
from urllib.parse import urlencode
from urllib.request import urlopen, Request
from urllib.error import HTTPError, URLError

from dotenv import load_dotenv


# Etherscan V2 API - unified endpoint with chainid parameter
# As of August 2025, V1 endpoints are deprecated
ETHERSCAN_V2_API = "https://api.etherscan.io/v2/api"

# Chain IDs for Etherscan V2 API
CHAIN_IDS = {
    "mainnet": 1,
    "ethereum": 1,
    "bsc": 56,
    "base": 8453,
    "polygon": 137,
    "arbitrum": 42161,
    "optimism": 10,
    "avalanche": 43114,
    "fantom": 250,
}

# Fallback to chain-specific APIs (legacy, may still work for some chains)
LEGACY_EXPLORER_APIS = {
    "mainnet": "https://api.etherscan.io/api",
    "ethereum": "https://api.etherscan.io/api",
    "bsc": "https://api.bscscan.com/api",
    "base": "https://api.basescan.org/api",
    "polygon": "https://api.polygonscan.com/api",
    "arbitrum": "https://api.arbiscan.io/api",
    "optimism": "https://api-optimistic.etherscan.io/api",
}

# Environment variable names for API keys per chain (V2 uses unified key)
API_KEY_ENV_VARS = {
    "mainnet": "ETHERSCAN_API_KEY",
    "ethereum": "ETHERSCAN_API_KEY",
    "bsc": "ETHERSCAN_API_KEY",  # V2 uses unified key
    "base": "ETHERSCAN_API_KEY",
    "polygon": "ETHERSCAN_API_KEY",
    "arbitrum": "ETHERSCAN_API_KEY",
    "optimism": "ETHERSCAN_API_KEY",
}


@dataclass
class SourceCodeResult:
    """Result of fetching source code from block explorer."""
    address: str
    chain: str
    contract_name: str
    source_code: str
    abi: list
    compiler_version: str
    optimization_used: bool
    runs: int
    constructor_arguments: str
    evm_version: str
    library: str
    license_type: str
    proxy: bool
    implementation: str | None
    # Multi-file support
    sources: dict[str, str] | None = None  # filename -> source code


class EtherscanFetcher:
    """Fetch contract source code and ABI from Etherscan V2 API."""

    def __init__(self, api_key: str | None = None, chain: str = "mainnet", use_v2: bool = True):
        """Initialize fetcher.

        Args:
            api_key: API key for the block explorer. If None, reads from env.
            chain: Chain name (mainnet, bsc, base, etc.)
            use_v2: Use Etherscan V2 API (default True, recommended)
        """
        self.chain = chain.lower()
        self.use_v2 = use_v2

        if self.chain not in CHAIN_IDS:
            raise ValueError(f"Unsupported chain: {chain}. Supported: {list(CHAIN_IDS.keys())}")

        self.chain_id = CHAIN_IDS[self.chain]

        if use_v2:
            self.api_url = ETHERSCAN_V2_API
        else:
            self.api_url = LEGACY_EXPLORER_APIS.get(self.chain, ETHERSCAN_V2_API)

        # Get API key from parameter or environment
        if api_key:
            self.api_key = api_key
        else:
            env_var = API_KEY_ENV_VARS.get(self.chain, "ETHERSCAN_API_KEY")
            self.api_key = os.getenv(env_var) or os.getenv("ETHERSCAN_API_KEY")

        if not self.api_key:
            raise ValueError(
                f"No API key found. Set {API_KEY_ENV_VARS.get(self.chain, 'ETHERSCAN_API_KEY')} "
                "in environment or pass api_key parameter."
            )

    def _make_request(self, params: dict) -> dict:
        """Make API request with rate limiting."""
        params["apikey"] = self.api_key

        # V2 API requires chainid parameter
        if self.use_v2:
            params["chainid"] = self.chain_id

        url = f"{self.api_url}?{urlencode(params)}"

        request = Request(url, headers={"User-Agent": "Mozilla/5.0"})

        try:
            with urlopen(request, timeout=30) as response:
                data = json.loads(response.read().decode("utf-8"))
        except HTTPError as e:
            raise RuntimeError(f"HTTP error {e.code}: {e.reason}") from e
        except URLError as e:
            raise RuntimeError(f"URL error: {e.reason}") from e

        # Rate limit: Etherscan free tier is 5 calls/sec
        time.sleep(0.25)

        return data

    def get_source_code(self, address: str) -> SourceCodeResult:
        """Fetch verified source code for a contract.

        Args:
            address: Contract address (with or without 0x prefix)

        Returns:
            SourceCodeResult with source code, ABI, and metadata

        Raises:
            RuntimeError: If contract not verified or API error
        """
        if not address.startswith("0x"):
            address = f"0x{address}"

        params = {
            "module": "contract",
            "action": "getsourcecode",
            "address": address,
        }

        data = self._make_request(params)

        if data.get("status") != "1":
            raise RuntimeError(f"API error: {data.get('message', 'Unknown error')}")

        result = data.get("result", [])
        if not result or not isinstance(result, list):
            raise RuntimeError(f"No source code found for {address}")

        contract_info = result[0]

        # Check if contract is verified
        if not contract_info.get("SourceCode"):
            raise RuntimeError(f"Contract {address} is not verified on {self.chain}")

        # Parse source code (can be JSON for multi-file contracts)
        source_code = contract_info["SourceCode"]
        sources = None

        # Handle multi-file format (starts with {{ or {)
        if source_code.startswith("{{"):
            # Double-braced JSON format
            source_code = source_code[1:-1]  # Remove outer braces
            try:
                parsed = json.loads(source_code)
                if "sources" in parsed:
                    sources = {
                        name: info.get("content", "")
                        for name, info in parsed["sources"].items()
                    }
                    # Combine all sources into single string for simple access
                    source_code = "\n\n".join(
                        f"// File: {name}\n{content}"
                        for name, content in sources.items()
                    )
            except json.JSONDecodeError:
                pass  # Keep original source code
        elif source_code.startswith("{"):
            # Single-braced JSON format
            try:
                parsed = json.loads(source_code)
                if isinstance(parsed, dict) and "sources" in parsed:
                    sources = {
                        name: info.get("content", "")
                        for name, info in parsed["sources"].items()
                    }
                    source_code = "\n\n".join(
                        f"// File: {name}\n{content}"
                        for name, content in sources.items()
                    )
            except json.JSONDecodeError:
                pass

        # Parse ABI
        abi = []
        if contract_info.get("ABI") and contract_info["ABI"] != "Contract source code not verified":
            try:
                abi = json.loads(contract_info["ABI"])
            except json.JSONDecodeError:
                pass

        return SourceCodeResult(
            address=address,
            chain=self.chain,
            contract_name=contract_info.get("ContractName", ""),
            source_code=source_code,
            abi=abi,
            compiler_version=contract_info.get("CompilerVersion", ""),
            optimization_used=contract_info.get("OptimizationUsed", "0") == "1",
            runs=int(contract_info.get("Runs", 0)),
            constructor_arguments=contract_info.get("ConstructorArguments", ""),
            evm_version=contract_info.get("EVMVersion", ""),
            library=contract_info.get("Library", ""),
            license_type=contract_info.get("LicenseType", ""),
            proxy=contract_info.get("Proxy", "0") == "1",
            implementation=contract_info.get("Implementation") or None,
            sources=sources,
        )

    def get_abi(self, address: str) -> list:
        """Fetch just the ABI for a contract.

        Args:
            address: Contract address

        Returns:
            ABI as list of dicts
        """
        if not address.startswith("0x"):
            address = f"0x{address}"

        params = {
            "module": "contract",
            "action": "getabi",
            "address": address,
        }

        data = self._make_request(params)

        if data.get("status") != "1":
            raise RuntimeError(f"API error: {data.get('message', 'Unknown error')}")

        try:
            return json.loads(data.get("result", "[]"))
        except json.JSONDecodeError as e:
            raise RuntimeError(f"Failed to parse ABI: {e}") from e

    def get_contract_creation(self, address: str) -> dict:
        """Get contract creation transaction info.

        Args:
            address: Contract address

        Returns:
            Dict with contractAddress, contractCreator, txHash
        """
        if not address.startswith("0x"):
            address = f"0x{address}"

        params = {
            "module": "contract",
            "action": "getcontractcreation",
            "contractaddresses": address,
        }

        data = self._make_request(params)

        if data.get("status") != "1":
            raise RuntimeError(f"API error: {data.get('message', 'Unknown error')}")

        result = data.get("result", [])
        if result:
            return result[0]
        return {}


def fetch_source_code(
    address: str,
    chain: str = "mainnet",
    api_key: str | None = None,
    cache_dir: Path | None = None,
) -> SourceCodeResult:
    """Convenience function to fetch source code with optional caching.

    Args:
        address: Contract address
        chain: Chain name (mainnet, bsc, base, etc.)
        api_key: Optional API key (reads from env if not provided)
        cache_dir: Optional directory to cache fetched sources

    Returns:
        SourceCodeResult with source code and metadata
    """
    # Load .env if not already loaded
    load_dotenv()

    # Check cache first
    if cache_dir:
        cache_file = cache_dir / f"{chain}_{address.lower()}.json"
        if cache_file.exists():
            data = json.loads(cache_file.read_text())
            return SourceCodeResult(**data)

    # Fetch from API
    fetcher = EtherscanFetcher(api_key=api_key, chain=chain)
    result = fetcher.get_source_code(address)

    # Cache result
    if cache_dir:
        cache_dir.mkdir(parents=True, exist_ok=True)
        cache_data = {
            "address": result.address,
            "chain": result.chain,
            "contract_name": result.contract_name,
            "source_code": result.source_code,
            "abi": result.abi,
            "compiler_version": result.compiler_version,
            "optimization_used": result.optimization_used,
            "runs": result.runs,
            "constructor_arguments": result.constructor_arguments,
            "evm_version": result.evm_version,
            "library": result.library,
            "license_type": result.license_type,
            "proxy": result.proxy,
            "implementation": result.implementation,
            "sources": result.sources,
        }
        cache_file.write_text(json.dumps(cache_data, indent=2))

    return result


if __name__ == "__main__":
    # Test the fetcher
    import sys

    load_dotenv()

    if len(sys.argv) < 2:
        print("Usage: python source_fetcher.py <address> [chain]")
        print("Example: python source_fetcher.py 0x5f58058C0eC971492166763c8C22632B583F667f mainnet")
        sys.exit(1)

    address = sys.argv[1]
    chain = sys.argv[2] if len(sys.argv) > 2 else "mainnet"

    try:
        result = fetch_source_code(address, chain)
        print(f"Contract: {result.contract_name}")
        print(f"Compiler: {result.compiler_version}")
        print(f"EVM Version: {result.evm_version}")
        print(f"Proxy: {result.proxy}")
        if result.implementation:
            print(f"Implementation: {result.implementation}")
        print(f"\nSource code length: {len(result.source_code)} chars")
        print(f"ABI functions: {len([x for x in result.abi if x.get('type') == 'function'])}")
        print("\n--- First 500 chars of source ---")
        print(result.source_code[:500])
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
