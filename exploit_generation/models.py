"""Data models for exploit generation."""

from dataclasses import dataclass, field
from pathlib import Path
import json


@dataclass
class LocalContract:
    """Contract loaded from local filesystem."""
    name: str
    source_path: Path
    source_code: str
    solidity_version: str
    vulnerability_type: str | None = None
    deployed_address: str | None = None

    def to_dict(self) -> dict:
        return {
            "name": self.name,
            "source_path": str(self.source_path),
            "source_code": self.source_code,
            "solidity_version": self.solidity_version,
            "vulnerability_type": self.vulnerability_type,
            "deployed_address": self.deployed_address,
        }


@dataclass
class BenchmarkCase:
    """Case from benchmark.csv for on-chain exploit generation."""
    case_name: str
    task_source: str
    chain: str  # "mainnet", "bsc", "base"
    fork_block_number: int
    target_contract_address: str
    evm_version: str | None = None
    # Fetched data
    source_code: str | None = None
    abi: list | None = None
    contract_name: str | None = None

    def to_dict(self) -> dict:
        return {
            "case_name": self.case_name,
            "task_source": self.task_source,
            "chain": self.chain,
            "fork_block_number": self.fork_block_number,
            "target_contract_address": self.target_contract_address,
            "evm_version": self.evm_version,
            "source_code": self.source_code,
            "abi": self.abi,
            "contract_name": self.contract_name,
        }

    @classmethod
    def from_csv_row(cls, row: dict) -> "BenchmarkCase":
        return cls(
            case_name=row["case_name"],
            task_source=row["task_source"],
            chain=row["chain"],
            fork_block_number=int(row["fork_block_number"]),
            target_contract_address=row["target_contract_address"],
            evm_version=row.get("evm_version") or None,
        )


@dataclass
class ExecutionTrace:
    """Parsed execution trace from forge."""
    success: bool
    revert_reason: str | None = None
    gas_used: int = 0
    state_changes: list[dict] = field(default_factory=list)
    internal_calls: list[dict] = field(default_factory=list)
    events: list[dict] = field(default_factory=list)
    balance_diff: dict[str, float] = field(default_factory=dict)
    raw_output: str = ""

    def to_dict(self) -> dict:
        return {
            "success": self.success,
            "revert_reason": self.revert_reason,
            "gas_used": self.gas_used,
            "state_changes": self.state_changes,
            "internal_calls": self.internal_calls,
            "events": self.events,
            "balance_diff": self.balance_diff,
        }


@dataclass
class ExploitResult:
    """Result of an exploit generation episode."""
    episode_id: str
    contract_name: str
    target_address: str
    success: bool  # Binary: profitable or not
    profit_native_token: float
    iterations: int
    execution_traces: list[dict] = field(default_factory=list)
    final_exploit_code: str = ""
    total_cost_usd: float = 0.0
    error: str | None = None

    def to_dict(self) -> dict:
        return {
            "episode_id": self.episode_id,
            "contract_name": self.contract_name,
            "target_address": self.target_address,
            "success": self.success,
            "profit_native_token": self.profit_native_token,
            "iterations": self.iterations,
            "execution_traces": self.execution_traces,
            "final_exploit_code": self.final_exploit_code,
            "total_cost_usd": self.total_cost_usd,
            "error": self.error,
        }

    def save(self, path: Path):
        path.write_text(json.dumps(self.to_dict(), indent=2))

    @classmethod
    def load(cls, path: Path) -> "ExploitResult":
        data = json.loads(path.read_text())
        return cls(**data)
