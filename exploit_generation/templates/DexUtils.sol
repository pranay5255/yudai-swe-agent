// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20Minimal {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
}

interface IUniswapV2RouterLike {
    function WETH() external pure returns (address);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external payable;
}

/// @notice DEX helpers for converting between ERC20 tokens and chain-native assets.
library DexUtils {
    // Mainnet Uniswap V2 router
    address internal constant UNISWAP_V2_ETHEREUM = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    // BSC PancakeSwap V2 router
    address internal constant PANCAKE_V2_BSC = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // Base Uniswap V2 router
    address internal constant UNISWAP_V2_BASE = 0x4752ba5Dbc23f44D87826276BF6fd6b1C372aD24;

    function swapExactTokenToBaseToken(address token, uint256 amount) internal {
        if (token == address(0) || amount == 0) {
            return;
        }

        address router = _routerForChain(block.chainid);
        if (router == address(0)) {
            return;
        }

        _safeApprove(token, router, 0);
        _safeApprove(token, router, amount);

        address wrappedNative = IUniswapV2RouterLike(router).WETH();
        if (token == wrappedNative) {
            return;
        }

        address[] memory path = new address[](2);
        path[0] = token;
        path[1] = wrappedNative;

        // Prefer direct token -> native swap so profits show up in native balance checks.
        try IUniswapV2RouterLike(router).swapExactTokensForETHSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        ) {} catch {
            // Fallback to token -> wrapped native for routers/chains that reject ETH out routes.
            try IUniswapV2RouterLike(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(
                amount,
                0,
                path,
                address(this),
                block.timestamp
            ) {} catch {}
        }
    }

    function swapExactBaseTokenToToken(address token, uint256 amount) internal {
        if (token == address(0) || amount == 0 || amount > address(this).balance) {
            return;
        }

        address router = _routerForChain(block.chainid);
        if (router == address(0)) {
            return;
        }

        address wrappedNative = IUniswapV2RouterLike(router).WETH();
        if (token == wrappedNative) {
            return;
        }

        address[] memory path = new address[](2);
        path[0] = wrappedNative;
        path[1] = token;

        try IUniswapV2RouterLike(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(
            0,
            path,
            address(this),
            block.timestamp
        ) {} catch {}
    }

    function swapExcessTokensToBaseToken(address token) internal {
        if (token == address(0)) {
            return;
        }

        uint256 balance = IERC20Minimal(token).balanceOf(address(this));
        if (balance == 0) {
            return;
        }

        swapExactTokenToBaseToken(token, balance);
    }

    // Backward-compatible no-arg overload.
    function swapExcessTokensToBaseToken() internal {
        // Intentionally a no-op when token is unspecified.
    }

    function _routerForChain(uint256 chainId) private pure returns (address) {
        if (chainId == 1) {
            return UNISWAP_V2_ETHEREUM;
        }
        if (chainId == 56) {
            return PANCAKE_V2_BSC;
        }
        if (chainId == 8453) {
            return UNISWAP_V2_BASE;
        }
        return address(0);
    }

    function _safeApprove(address token, address spender, uint256 value) private {
        (bool ok, bytes memory data) = token.call(
            abi.encodeWithSelector(IERC20Minimal.approve.selector, spender, value)
        );
        if (!ok) {
            return;
        }
        if (data.length == 0) {
            return;
        }
        if (data.length == 32 && abi.decode(data, (bool))) {
            return;
        }
    }
}
