"""Foundry environment specialized for exploit generation with trace parsing (V2)."""

from __future__ import annotations

import logging
import re
from typing import Any

from minisweagent.environments.extra.foundry_parsed_v2 import BlockchainCommandParserV2
from minisweagent.environments.foundry_v2 import FoundryEnvironmentV2

try:
    from exploit_generation.trace_parser import (
        format_trace_for_llm,
        parse_forge_script_output,
    )
except Exception:  # pragma: no cover - optional dependency
    format_trace_for_llm = None
    parse_forge_script_output = None


class ExploitCommandParserV2(BlockchainCommandParserV2):
    """Extend the default parser with full forge script traces (V2)."""

    def _parse_forge_script(self, output: str, returncode: int) -> dict[str, Any]:
        if parse_forge_script_output is None or format_trace_for_llm is None:
            return super()._parse_forge_script(output, returncode)

        trace = parse_forge_script_output(output, returncode)
        summary = format_trace_for_llm(trace)
        return {
            "kind": "forge_script",
            "summary": summary,
            "details": trace.to_dict(),
        }


class ExploitFoundryEnvironmentV2(FoundryEnvironmentV2):
    """Foundry environment with exploit-focused trace parsing and helpers (V2)."""

    def __init__(self, *args, parser: ExploitCommandParserV2 | None = None, **kwargs):
        super().__init__(*args, **kwargs)
        self._parser = parser or ExploitCommandParserV2()
        self.execution_traces: list[dict[str, Any]] = []
        self.logger = logging.getLogger("minisweagent.environment.exploit_foundry_v2")

    def execute(self, command: str, cwd: str = "", *, timeout: int | None = None) -> dict[str, Any]:
        result = super().execute(command, cwd=cwd, timeout=timeout)
        parsed = self._parser.parse(command, result)
        if not parsed:
            return result

        result = dict(result)
        result["parsed"] = parsed
        result.setdefault("raw_output", result.get("output", ""))
        result["output"] = parsed.get("summary", result["output"])

        if parsed.get("kind") == "forge_script":
            details = parsed.get("details")
            if details is not None:
                self.execution_traces.append(details)

        return result

    def fund_account(self, address: str, balance_wei: int, rpc_url: str = "") -> dict[str, Any]:
        """Fund an account using anvil's built-in balance command."""
        rpc_url = rpc_url or self.get_anvil_rpc_url()
        cmd = f"cast rpc anvil_setBalance {address} {hex(balance_wei)} --rpc-url {rpc_url}"
        return self.execute(cmd)

    def deploy_contract(
        self,
        target: str,
        *,
        private_key: str,
        rpc_url: str = "",
        constructor_args: list[str] | None = None,
    ) -> str:
        """Deploy a contract via forge create and return the deployed address."""
        rpc_url = rpc_url or self.get_anvil_rpc_url()
        cmd = f"forge create {target} --rpc-url {rpc_url} --private-key {private_key}"
        if constructor_args:
            cmd += " --constructor-args " + " ".join(constructor_args)

        result = self.execute(cmd)
        output = result.get("raw_output") or result.get("output", "")
        match = re.search(r"Deployed to:\s*(0x[a-fA-F0-9]{40})", output)
        if not match:
            raise RuntimeError(f"Failed to parse deployed address from output:\n{output}")
        return match.group(1)

    def get_balance_ether(self, address: str, rpc_url: str = "") -> float:
        """Get an address balance in ETH/BNB as a float."""
        rpc_url = rpc_url or self.get_anvil_rpc_url()
        cmd = f"cast balance {address} --ether --rpc-url {rpc_url}"
        result = self.execute(cmd)
        raw = result.get("raw_output") or result.get("output") or ""

        # Filter out warning/info lines to get the actual balance value
        lines = raw.strip().splitlines()
        for line in lines:
            line = line.strip()
            # Skip empty lines and common warning/info prefixes
            if not line:
                continue
            if line.lower().startswith(("warning:", "info:", "error:", "note:")):
                continue
            if "nightly build" in line.lower():
                continue
            if "recommended to use" in line.lower():
                continue
            # Try to parse as a number - if it works, it's likely the balance
            try:
                return float(line)
            except ValueError:
                continue

        # If we couldn't find a valid balance, report the full output for debugging
        raise RuntimeError(f"Failed to parse balance from output:\n{raw[:500]}")
