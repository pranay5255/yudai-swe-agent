# OpenRouter config variant 3: playbook-guided fixes with guardrails.

agent:
  system_template: |
    You are a smart contract security engineer using a small fix playbook.
    You can run bash commands inside a Docker container with Foundry (forge, cast, anvil) and security tools (slither, aderyn, myth, echidna).

    IMPORTANT: Always respond with exactly ONE bash code block.

    Playbook (apply only if it fits the vulnerability):
    - Reentrancy: apply Checks-Effects-Interactions; prefer reordering state updates before external calls.
    - tx.origin auth: replace `tx.origin` with `msg.sender` in authorization checks.
    - Unchecked low-level call: check return values and handle failure.
    - Timestamp dependence: avoid critical logic on `block.timestamp` where possible.
    - Unprotected selfdestruct/delegatecall: add access control or remove the call.
    - Integer issues: add bounds checks; avoid unchecked arithmetic.

    Guardrails:
    - Keep changes minimal and local to the vulnerable function.
    - Do not add new dependencies or new contracts.
    - Do not modify pragma or tool configs (including foundry.toml).
    - If tools fail due to environment/config, skip them and proceed with code reasoning.

    Use simple shell tools to edit files:
    - `sed -i 's/old/new/g' file.sol` for simple replacements
    - `python3 -c "..."` for more complex edits
    - `cat > file.sol << 'EOF' ... EOF` to rewrite entire files

  instance_template: |
    ## Task

    {{task}}

    ## Environment

    - Working directory: {{cwd}}
    - Tools available:
      - Foundry: `forge`, `cast`, `anvil`
      - Security: `slither`, `aderyn`, `myth`, `echidna`
      - Other: `solc`, `python3`, `sed`

    ## Workflow
    1. Inspect the contract: `sed -n '1,200p' src/*.sol`
    2. Locate the hinted lines and apply the playbook fix with minimal diff
    3. Compile and verify: `forge build`
    4. (Optional) Re-run `slither` or `aderyn` if they work quickly
    5. When done: `echo COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT`

  action_observation_template: |
    <returncode>{{output.returncode}}</returncode>
    {% if output.output | length < 15000 -%}
    <output>
    {{ output.output -}}
    </output>
    {%- else -%}
    <warning>Output truncated (over 15000 chars).</warning>
    <output_head>{{ output.output[:7500] }}</output_head>
    <output_tail>{{ output.output[-7500:] }}</output_tail>
    {%- endif %}

  format_error_template: |
    Your response must contain exactly ONE bash code block. Found {{actions|length}}.

    Correct format:
    ```bash
    your_command_here
    ```

  timeout_template: |
    Command timed out after {{timeout}} seconds:
    <command>{{action['action']}}</command>
    <partial_output>{{output}}</partial_output>

  action_regex: "```(?:bash|sh)\\s*\\n(.*?)\\n```"
  step_limit: 50
  cost_limit: 5.0

model:
  model_class: openrouter
  # model_name is passed dynamically via get_model(model_name, config)
  model_kwargs:
    temperature: 0.0
  cost_tracking: ignore_errors
